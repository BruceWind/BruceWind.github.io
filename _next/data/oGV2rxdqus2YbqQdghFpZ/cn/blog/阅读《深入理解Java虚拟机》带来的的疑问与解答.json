{"pageProps":{"post":{"slug":"阅读《深入理解Java虚拟机》带来的的疑问与解答","title":"阅读《深入理解Java虚拟机》带来的的疑问与解答.md","mdsource":"md/阅读《深入理解Java虚拟机》带来的的疑问与解答.md","date":" 2017/01/24 16:29:54","category":"几年后回看会觉得写的太烂"},"content":"title: 阅读《深入理解Java虚拟机》带来的的疑问与解答\ndate: 2017/01/24 16:29:54\nupdated: 2017/02/04 11:17:05\ncategories:\n- 技术\n---\n### 1.JVM参数中 xms xmx到底是指整个内存区，还是指堆区？\n解：堆区。如你所见，如果native中申请内存过多也会使app发生OOM，因为native申请内存在native heap，java则是在dalvik heap。\n### 2.DVM和JVM最大的区别是什么?\nDVM跟JVM很多方面类似，但是DVM是基于寄存器，JVM是基于栈的。这是最大的设计区别，另外的区别就是：DVM的字节码是dex,JVM是class。\n打包时：\n```\nJAVA编译器: java    ->  .class  ->  .jar    ->  war/ear(包含其他资源)\n安卓编译器: java    ->  .class  ->  .dex    ->  .apk(包含其他资源)\n```\n\n### 3.dex文件比jar的优势在哪里?\n解:移除多余的类,减少类加载时的内存消耗。\n### 4.ART虚拟机作为dalvik虚拟机的升级版本，为何导致安装变慢了？\n解：老的dalvik已经不再维护了，他在安装时，直接从apk中解包拿到dex文件就可以执行了，dalvik还在使用JIT技术来加快java执行的速度，始终不如C语言,C语言build生成的字节码就是机器码，所以速度更快，所以ART虚拟机放弃使用JIT方案，ART虚拟机从apk中解包得到dex文件之后还要再把dex文件转成本地机器码，模仿C语言的做法让java可以更快更高更强，所以ART虚拟机比dalvik多执行了一步过程就变慢了。\n上面有个打包时，把ART也加进来对比。\n# \n安装过程：\n```\nJVM     :war/ear->jar   --------->  bytecode(class)\ndalvik  :apk->dex       --dexopt->  bytecode(odex)\nART     :apk->dex       --------->  machinecode\n```\n\n### 5.ART虚拟机作为dalvik虚拟机的升级版本，为何运行更快了？\n所有JVM执行时都需要machinecode，而上面说了，这里ART直接就拿到了machinecode.\nJava字节码的执行有两种方式： \n通常采用的是第二种方法或者两种配合，DVM直接就是采用第一种。\n\n> - 即时编译方式(JIT)：解释器先将字节码编译成机器码，然后再执行该机器码。 \n> - 解释执行方式(暂且称为JT)：解释器通过每次解释并执行一小段代码来完成Java字节码程序的所有操作。 \n\n三种虚拟机，启动到运行：\n```\nJVM     :   bytecod --JT--->    启动生成machinecode             -> run machinecode\ndalvik  :   bytecode(启动啥也不做)  -JIT运行时生成machinecode   -> run machinecode\nART     :   machinecode(启动啥也不做)                           -> run machinecode\n```\n\n\n### 6.dvm采用的GC算法是什么?\n解:复制和标记清除算法,《深入理解Java虚拟机》中指出：目前常见的jvm版本都会采用多种GC算法配合使用，以达到更好的GC算法效果。","lang":"cn"},"__N_SSG":true}