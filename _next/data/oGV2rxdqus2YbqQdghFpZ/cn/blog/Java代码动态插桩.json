{"pageProps":{"post":{"slug":"Java代码动态插桩","title":"Java代码动态插桩.md","mdsource":"md/Java代码动态插桩.md","date":" 2017/03/23 20:26:54","category":"几年后回看会觉得写的太烂"},"content":"title: Java代码动态插桩\ndate: 2017/03/23 20:26:54\nupdated: 2017/05/19 12:24:43\ncategories:\n- 技术\n---\n代码插桩方案有n种，就不一一细说。说下常用的几种。\n\n## 1.利用动态代理InvocationHandler\n\n我动手写了个例子，这个类的目的是让方法执行之前，打印每个方法的方法名和参数，因为我老是遇到类似需求，需要我打印一个观察者的所有的方法的执行日志。\n\n``` java\n\n/**\n * =======让类的每个方法都执行时打印日志========\n * demo:\n *\n *  SMObserver mSMObserver = new SMObserver();\n *  SMObserverInterface me=(SMObserverInterface)MethodDynamicLogger.generatorInterface(mSMObserver);\n *  me.something();\n );\n */\npublic class MethodDynamicLogger implements InvocationHandler {\n\n    Object mObject;\n    CoreLogger mCoreLogger;//使用CoreLogger 在release版本跳过 打印日志\n    public MethodDynamicLogger(Object obj) {\n        mObject = obj;\n        String tag =\" \"+mObject.getClass().getSimpleName()+\"-->\";\n        mCoreLogger=CoreLogger.getLogger(tag);\n    }\n\n\n    @Override\n    public Object invoke(Object o, Method method, Object[] args) throws Throwable {\n        StringBuilder builder=new StringBuilder(method.getName()+\"(\");\n\n        if(args!=null)\n        {\n            Iterator<Object> iterator= Arrays.asList(args).iterator();\n            while (iterator.hasNext())\n            {\n                builder.append(iterator.next()+\"\");\n                if(iterator.hasNext()) {\n                    builder.append(\" , \");\n                }\n            }\n        }\n        builder.append(\")\");\n\n        mCoreLogger.d(builder.toString());\n        method.invoke(mObject, args);\n        return null;\n    }\n\n    private Object generator()\n    {\n        return Proxy.newProxyInstance(\n                mObject.getClass().getClassLoader(),\n                mObject.getClass().getInterfaces(),\n                this\n        );\n    }\n\n\n    public static Object generatorInterface(Object obj)\n    {\n        return new MethodDynamicLogger(obj).generator();\n    }\n}\n\n```\n\n这里SMObserverInterface 是一个interface，SMObserver是一个类，SMObserver只要implement这个interface，我就可以实现代码插桩，就用这个代理去绑定了observer的每个方法，在每个方法执行之前打印方法名和参数。\n这种方案比较适用于类的初始化由自己控制的，是自己给自己的代码插桩。\n\n## 2.编译时生成\n\n其实我的github上有个项目：[GeneratorX](https://github.com/BruceWind/GeneratorX),就是利用编译时生成，我是利用java的编译时生成。\n\n这种方案其实在butterknife上也在使用。你只是简单写了一个注解，然后butterknife利用JAVA的AbstractProcessor类实现生成代码，把findview和setOnClick事件的代码帮你插入到代码里。\n\n\n## 3.修改字节码\n我写了个修改字节码的demo挂在github上。[https://github.com/BruceWind/Jar_Hook](https://github.com/BruceWind/Jar_Hook)\n\n\n``` java\n//jar包中的代码：\npackage com.androidyuan;\n\npublic class Hello {\n    public Hello() {\n    }\n\n    public static void sayHello(String name) {//被hook的方法\n    }\n}\n```\n\n在sayHello方法里插入了`MainActivity.hookXM(String name);`.\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        ...\n        ...\n        Hello.sayHello(\"hello\");\n    }\n\n    public static void hookXM(String name) {//插入执行这行代码\n        Log.i(\"hookXM\", \"hello av8d,im \"+name+\".\");\n    }\n}\n```\n*执行效果请run起来看日志。*\n\n### 目前实现原理\n\n利用修改字节码技术，[hibeaver](https://github.com/BryanSharp/hibeaver)是ASM基于gradle的一种包装方案，核心原理在于ASM框架。\n\n~~《ASM从入门到放弃》~~ \n~~太长不看~~\nASM是一个老牌字节码框架。当然了，字节码操作的框架这几年有很多，只不过目前ASM是很多项目都在使用的罢了，包括kotlin也在使用。\n\n\n利用ASM框架hook一个jar包内的一个方法，实现代码插桩。\n目前，仅仅在编译期间hook，没有在运行时hook.\n\n### 在运行期hook是否是一种可行性方案？\n\n> + Dalvik:\n    理论上来说运行时hook也可以，基于ASMDEX框架就好，Dalvik机器使用java字节码解释执行，运行期间也不断被自带JIT编译器修改着字节码。\n\n> + Art:\n    但是Art虚拟机之后，apk安装之后会把字节码转为跟其他C或C++同样方案的机器码，这样子以机器码加速执行的性能非常高。\n    DVM是不遵守JVM规范的虚拟机。\n    Art在不同的版本之间实现大大变化，最初只有AOP没有JIT，后来又加入了JIT。\n\n**综上：**\n    android平台还是老老实实的使用编译后期hook的方案吧。\n\n## 4.专门用于代码插桩的框架\n比较知名的有[BCEl](http://blog.csdn.net/yczz/article/details/14497897)，[JIAPI](http://jiapi.sourceforge.net/)。\n我就不写demo了，毕竟那样太辛苦了( @_@ )，上面几种我已经写了demo了，本文的目的在于分享，不在于练代码啊！！！！  \n这种东西的变种就是IDE插件，帮你用插件实现代码插桩。\n\n# \n其实，回过头来看，java的开放，编译时生成，运行时可修改字节码，反射，使用隐藏API等等，这些东西都足以说明一个问题：代码安全性几乎是没有的，我想hack你，想让你死，我可以瞬间想到一百种致你于死地的方法，哈哈哈！！ 开玩笑。。。\n\n\n","lang":"cn"},"__N_SSG":true}