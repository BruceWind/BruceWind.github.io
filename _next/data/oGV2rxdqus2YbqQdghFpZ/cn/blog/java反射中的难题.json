{"pageProps":{"post":{"slug":"java反射中的难题","title":"java反射中的难题.md","mdsource":"md/java反射中的难题.md","date":" 2016/07/04 14:24:18","category":"几年后回看会觉得写的太烂"},"content":"title: java反射中的难题\ndate: 2016/07/04 14:24:18\nupdated: 2016/11/25 11:35:54\ncategories:\n- 技术\n---\n## 1.访问私有对象（这个是比较简单，不算是难题）\n\n使用反射:\n```\n        Field field[] = reClass.getDeclaredFields();\n        field[0].setAccessible(true);\n        field[0].set(obj, value);//给obj的一个属性设置value\n```\n\n## 2.访问私有方法 （这个是比较简单，不算是难题）\n\n        Method[] methods = reClass.getDeclaredMethods();\n        methods[0].setAccessible(true);\n        methods[i].invoke(obj)；//调用obj的一个带参数方法\n\n## 3.某个类使用private修饰了无参构造函数()\n```\n//使用私有构造函数创建实例化这个对象\n    Constructor[] constructors = cls.getDeclaredConstructors();\n\tconstructors[0].setAccessible(true);\n\tconstructors[0].newInstance( )\n```\n\n## 4.某个类使用private修饰了带参构造函数,如果你特么的还非要访问这个带参构造函数的话\n\n```\npublic class FooCls {\n\n    private FooCls(int i)\n    {}\n}\n\n\n//实例化带参私有构造函数\n    int i=0;\n    Constructor[] constructors = cls.getDeclaredConstructors();\n\tconstructors[0].setAccessible(true);\n\tconstructors[0].newInstance(i);\n```\n## 5.实例化内部类 （这个也是很困难）\n\n```\n    /**\n     * 解决内部类无法构造问题\n     * @param parentClass  必须提供父类 否则无法实例化内部类\n     * @param reClass  内部类class\n     * @return 实例化之后的内部类对象\n     * @throws IllegalAccessException\n     * @throws InstantiationException\n     * @throws InvocationTargetException\n     */\nprivate Object createInnerClsObj(Class parentClass,Class reClass) throws IllegalAccessException, InstantiationException, InvocationTargetException {\n\n        Object  parent=createObj(parentClass);\n\n        Constructor[] cons = reClass.getDeclaredConstructors();//强制让 private 构造函数可以访问\n        cons[0].setAccessible(true);\n        return cons[0].newInstance(parent);// 调用无参构造函数  只是子类的构建需要父类的支持\n    }\n    \n    \n    private Object createObj(Class reClass) throws IllegalAccessException, InvocationTargetException, InstantiationException {\n\n        Constructor[] cons = reClass.getDeclaredConstructors();//强制让 private 构造函数可以访问\n        cons[0].setAccessible(true);\n        return cons[0].newInstance();// 调用无参构造函数\n    }\n```\n\n## 6.类只提供了带参构造函数，想要实例化这个对象并通过无参构造去实例化\n\n    因为你只有带参构造函数，所以这里想要使用无参构造就变得异常艰难，java官方设计就不想让你这么做，我找了很多方案都发现没有这种方案。所以我选择试试fastjso怎样。\n    \n测试，发现其实fastjson也没有实现这个功能，我用fastjsonparse字符串的时候，一旦给的一个class只有一个带参的构造函数，类似上面**4**的，他就无法通过反射帮我实例化了，直接返回空对象回来。\n\n测试用代码如下:\n```\npublic class FooCls {\n\n    public FooCls(int i)\n    {}\n    int  els=0;\n}\n\n        //测试\n        QMJSONHelper qmjsonHelper=new QMJSONHelper(\"{\\\"els\\\":1}\");\n        FooCls foo=(FooCls)qmjsonHelper.parse2Model(FooCls.class);\n        Log.d(\"foo\",foo.toString());\n    \n\n```\n后来，实验Gson竟然是可以得到这个对象的。666！！ 谷歌团队黑科技！！\n\n\n# 不行我要学习。\n仔细阅读GSON的源码，并且进去调试，发现`UnsafeAllocator`这个类。内部使用反射得到了`Unsafe`这个类，但是这个类压根就没有开放出来，我无法引用这个类。所以谷歌故意通过Class.forName()去得到这个类，然后执行了这个类的一个static方法。\n```\npublic abstract class UnsafeAllocator {\n  public abstract <T> T newInstance(Class<T> c) throws Exception;\n\n  public static UnsafeAllocator create() {\n    // try JVM\n    // public class Unsafe {\n    //   public Object allocateInstance(Class<?> type);\n    // }\n    try {\n      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n      f.setAccessible(true);\n      final Object unsafe = f.get(null);\n      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) allocateInstance.invoke(unsafe, c);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, post-gingerbread\n    // public class ObjectStreamClass {\n    //   private static native int getConstructorId(Class<?> c);\n    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n    // }\n    try {\n      Method getConstructorId = ObjectStreamClass.class\n          .getDeclaredMethod(\"getConstructorId\", Class.class);\n      getConstructorId.setAccessible(true);\n      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n      final Method newInstance = ObjectStreamClass.class\n          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, constructorId);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, pre-gingerbread\n    // public class ObjectInputStream {\n    //   private static native Object newInstance(\n    //     Class<?> instantiationClass, Class<?> constructorClass);\n    // }\n    try {\n      final Method newInstance = ObjectInputStream.class\n          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, Object.class);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // give up\n    return new UnsafeAllocator() {\n      @Override\n      public <T> T newInstance(Class<T> c) {\n        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n      }\n    };\n  }\n\n  /**\n   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers\n   * throw an {@link UnsupportedOperationException}\n   * @param c instance of the class to be checked\n   */\n  private static void assertInstantiable(Class<?> c) {\n    int modifiers = c.getModifiers();\n    if (Modifier.isInterface(modifiers)) {\n      throw new UnsupportedOperationException(\"Interface can't be instantiated! Interface name: \" + c.getName());\n    }\n    if (Modifier.isAbstract(modifiers)) {\n      throw new UnsupportedOperationException(\"Abstract class can't be instantiated! Class name: \" + c.getName());\n    }\n  }\n}\n```\n# \n```\n    //用法很简单：\n    final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n    return unsafeAllocator.newInstance(reClass);\n\n```\n\n用Gson里面这个UnsafeAllocator 可以完美实现不开放默认构造函数的类的实例化。这个方案同时可以解决**4**的问题。\n\n## 7.取得泛型的类型，并new出来(这个很困难，多数人都告诉我：不能)\n```\n//给出我在 MVP中的例子\n\npublic abstract class BaseCommActivity<P extends BaseCommPresenter> extends FragmentActivity implements IBaseCommView,OnClickListener,OnReciverListener {\n\n\n    protected P presenter;\n\n    public BaseCommActivity() {\n\n        try {\n            //执行默认 构造函数\n//            presenter = getPsClass().newInstance();\n\n            Class<P> cls=((Class)((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[0]);\n\n            Constructor[] constructors=cls.getDeclaredConstructors();\n            constructors[0].setAccessible(true);//这句代码 意义不大 仅仅防止构造函数private\n\n            presenter=cls.newInstance();\n\n        } catch (InstantiationException e) {\n            e.printStackTrace();//这个异常通常不会发生 除非你的泛型类型是 Integer Boolean Long 这些\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();  //\n        }\n\n        presenter.setIView(this);\n    }\n\n```\n\n\n\n## Java Doc上的说明\n\n\n    getFields()获得某个类的所有的公共（public）的字段，包括父类。 \n\n    getDeclaredFields()获得某个类的所有申明的字段，即包括public、private和proteced，但是不包括父类的申明字段。 \n\n    同样类似的还有getConstructors()和getDeclaredConstructors()，getMethods()和getDeclaredMethods()。\n\n\n\n    Method getDeclaredMethod(String name, Class… parameterTypes)d \n          返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 \n    Method[] getDeclaredMethods() \n          返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 \n    Method getMethod(String name, Class… parameterTypes) \n          返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 \n    Method[] getMethods() \n          返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。 \n    getDeclaredField(String name) \n          返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 \n    Field[] getDeclaredFields() \n          返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段，包括公共、保护、默认（包）访问和私有字段，但不包括继承的字段。\n\n\n# \n# \n> - https://dunwood.blogspot.com/2004/05/instantiate-java-class-that-has.html\n\n\n","lang":"cn"},"__N_SSG":true}