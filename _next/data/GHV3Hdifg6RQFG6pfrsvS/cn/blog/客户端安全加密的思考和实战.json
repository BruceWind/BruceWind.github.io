{"pageProps":{"post":{"slug":"客户端安全加密的思考和实战","title":"客户端安全加密的思考和实战.md","mdsource":"md/客户端安全加密的思考和实战.md","date":" 2017/02/18 21:53:33","category":"几年后回看会觉得写的太烂"},"content":"title: 客户端安全加密的思考和实战\ndate: 2017/02/18 21:53:33\nupdated: 2017/02/19 16:58:41\ncategories:\n- 技术\n---\n本文是面向native安全设计。\n> 大家所知道的android程序员再代码安全方面做的大多数仅仅是把代码放到到so里面就可以了，那么实际上这样子安全吗？\n实际上，我作为一个爱思考的android程序员，我连会hack玩的一些高端的东西都不会，也轻松破解你。\n\n# \n在参与一个项目时，发现安全加密需要客户端做，但是作为一个有代码精神的程序员，我有几个问题需要慎重参与跟同事考虑几个重要的问题：\n1.使用什么加密算法？\n2.算法怎么保密？\n3.key怎么做保密？\n4.hack常见的破解我本地代码的手段是什么？\n\n\n常见的大家都是去做对称加密， 来保证网络传输的数据安全性，算法大家一般都是AES，可能老的一些项目还在使用3DES算法，AES主要就是性能高所以目前大量放弃AES。\n# \n回到破解的方向考虑，我怎么防止被人破解：\n### 几种方案：\n 1.key存到so中:\n> 作为一个开发者来说，你觉得key是加密的核心，你把key存到native中，然而，我反编译一下apk，从java代码里看到你的全部代码是AES算法，我觉得破解你的核心是key，我只要拿到你的key，看到你把key存到c中了，通过调用一个jni接口，就可以拿到你的key，这个时候我的破解方案就是，修改你的java代码，在代码里插入一行代码把jni取到的key打印到日志里，再二次打包运行即可。\n# \n2.key和算法都存在so中：\n> 如果上面的破解者只是一个普通的android程序员，可能这个时候还是可以破解你的，他不再目的为了取到你的key，而是仅仅当作你的so只是一个加密算法而已，我不用去破解你的so，只需要知道怎么调用你即可，我编译一下你的apk，看下你的java代码，就看到你怎么调用了，我就可以在新项目里就可以调用。\n这样子的话，我有个高级的方案，就是防止二次打包，问题在于，这个时候我怎么防止你二次打包，这个解决方案就是keystore的md5或者hashcode，就是在java调用so中的加密算法时，c的代码里要先去检查一下当前应用的包名应用的keystore的hashcode。这个校验一定要在c里面做，java太容易篡改，于是会有下面一个安全方案：\n# \n3.key 和 算法同时在so中，并做防止二次打包的校验：\n> 这个时候，做为一个android程序员我已经很难破解了，我看不到你的key，最多，我只能在反编译apk dex文件时看到你的jni接口的命名，大概看出你是aes算法加密，只是我拿不到你的key。但是，目前我已经几乎看到两个点。这个时候，作为一个android程序可能很难破解你了。\n普通android程序员大概只是知道你是一个aes算法，但是，我如果能拿到你的key，还是可以破解。\n这个时候，我用IDA去反汇编so，发现竟然直接看到了你的key，这个时候怎么防止我去反汇编呢？\nndk有个配置是符号表，可以用符号表存一些字符串，把这些东西存到符号表中，然后再ndk编译时使用隐藏符号表的方案。\nok，是的这是个好方案。\n在尝试之后发现反汇编之后确实无法看到key的字符串了。IDA和objdump两个软件都有尝试结果同样看不到字符串了。\n第一张，图我代码里使用了 `uint8_t AES_KEY[] = \"1234567890abcdef\";`\n![](assets/key.png)\n第二张图我反汇编之后，还可以看到这个字符串。\n![](assets/section.png)\n\n\n# \n4.key 和 算法同时在so中，并做防止二次打包的校验,在隐藏符号表\n> 这个时候，IDA是不行了，然后作为一个linux用户，我想想别的方案，发现apt仓库里有个objdump，我用objdump反编译一下，直接就看到你key。\n那么现在怎么办呢？有个方案，就是我的代码里存的key并不是一个真实的key，我把key做一些变换之后才能用，变换的代码我写在c里面，调用so里面的加密算法之前，我需要先调用c的init方法，生成好真实的key。\n# \n5.非真实的key存在so中，再生成真实的key，同时给so，做防止二次打包的校验\n> 那么，我想办法还是可以破解你，我利用堆栈溢出从内存地址中取到你生成好的key。\n这时候，从这个攻防的等级逐渐加深，你会发现，原来key是非常不安全，总能想办法破解你，拿到你的key。\n# \n## 加密的核心无非就是两点：\n> - 1.加密算法\n> - 2.key\n算法方面除非你用自定义加密算法，否则很难保证不被人猜到，就那么常见的几种加密方式，AES，DES杂七杂八。\n那么，key的安全性设计就是更加的难了，只要你的key写在代码里，或者通过运行时生成的方式生成再内存中，我总是可以详尽办法拿到你的key。\n这样子的话，算法和key都很好搞定。\n\n# 所以\n最好的安全设计方案是自定义加密啊算法，在AES上面大量的修改，或者在Base64上做大量修改，c的代码被打包成机器码之后不但很难看懂，而且几乎没法二次打包，另外就是本地客户端不存key，也不通过服务端下去发key。\n几个常见的例子：\n##《模仿游戏》\n模仿游戏中德国采用的“英格码”无法破译，他的涉及思想就是网络传输中不发送key，同时没有一个固定的key，防止你去破解，就是动态key技术，导致你就算抓到他的秘文用超级计算机取暴力破解，破解出来也已经是当时的key了，你再去破解今天的数据的时候，key已经变了。\n这个是到动态key的涉及思想。\n\n## SSH的设计思想\n本机电脑上存储一个key，server端存储一个key，使用者一般通过key访问server，key涉及的特别的复杂，就算超级计算机破解也需要很长时间，如果用户发现自己的key被破解了，那么直接后台删除掉这个key重新生成一个key。这也是一种动态key设计思想，只不过他的变化规律无迹可循，而且用户可以再自己帐号被盗之后重置加密key。\n\n# \n这都是针对你的平台田地多，防止专业的破解团体来说的，而针对小的破解团体的话，你只要保证算法不被猜到，同时客户端不存key，而且不在网络传输的传递key即可提升破解难度。\n\n    想起曾经参加安卓巴士搞得一个安全方面的座谈会，我靠，360和阿里聚安全的大佬在台上信誓旦旦的说只要你把所有的代码放到native去实现，安全就已经提升了很高的等级，但是后来自己尝试破解native才知道，他妈的都是狗屁，破解native也特么的很简单。\n\n#  反汇编可以看到很多东西\n1.方法名：就可以看到你的加密算法了，这个时候你可以用JniOnload去做映射，防止被看到方法名。\n2.代码里写的string，所以key完全不能存到代码里。\n\n## 所以，为了防止被反汇编，有一些方案去帮助你\n\n利用使用O-LLVM在NDK打包so时进行混淆处理，增加那些专门做逆向编程的人的破解难度。\n如果本地非要存字符串，请不要存真实的，而是需要经过转换的字符，先存一个非真实字符到字符表，再配置隐藏字符表，然后运行时不能把key生成到一个static字段中，这样子很容易利用堆栈溢出pop出你的值，所以就算做本地转换也请用短生命域的临时变量去做，用完即可丢弃，c的释放内存速度超级快，只要引用计数降低到0即可释放，也就是说这段加密算法走完，key就丢弃了。\n例子代码：\n```\nstatic char* base_key=\"HJDKHFDSJFDFHA324723894djksfh\";\n\nchar* encode(Stirng str)\n{\n    return encode(str,getRealKey(base_key));\n}\n\nchar* encode(char* str,char* key)\n{\n    char * strEncode;\n    //todo something\n    return strEncode;\n}\n\nchar * getRealKey(char* base)\n{\n    char* realk=\"\";\n\n    //TODO something\n    return realk;\n}\n```\n这样子，你代码里并没有存真实的key，然后NDK打包又经过混淆，做逆向的人就很难从汇编中看出你的生成key 的算法了，想要利用堆栈溢出pop出你存在静态变量里的key也拿不到真实的key，而动态字段存在内存空间中的时间1毫秒都不到根本不能pop出。\n\n\n## 鸣谢\n\n> https://www.linux.com/blog/4-ways-password-could-be-hacked-using-common-linux-tools","lang":"cn"},"__N_SSG":true}