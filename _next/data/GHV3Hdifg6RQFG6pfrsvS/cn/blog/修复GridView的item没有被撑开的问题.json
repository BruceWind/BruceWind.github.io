{"pageProps":{"post":{"slug":"修复GridView的item没有被撑开的问题","title":"修复GridView的item没有被撑开的问题.md","mdsource":"md/修复GridView的item没有被撑开的问题.md","date":" 2015/12/14 10:24:33","category":"几年后回看会觉得写的太烂"},"content":"title: 修复GridView的item没有被撑开的问题\ndate: 2015/12/14 10:24:33\nupdated: 2015/12/18 15:55:23\ncategories:\n- 技术\n---\n由于item中高度不同 导致的 看到背景色而且 item的布局无法fillparent。因为再gridview中嘛。既然高度无法fillparent，那么也无法居中就蛋疼了。\n# \n\n![](assets/5673bbfaab6441660a003571.PNG)\n\n# \n\n所以我需要重写gridview来重置item的高度。\n\n\n\n``` java\n\npublic class FixChildHeightGridView extends GridView {\n\n\n    private int mHeight = 0;\n\n    public void setmHeight(int i_hei) {\n        mHeight = i_hei;\n    }\n\n    //恢复默认  等待进行重新计算\n    public void revertDefault()\n    {\n        mHeight=0;\n    }\n\n    public FixChildHeightGridView(Context context) {\n\n        super(context);\n    }\n\n    public FixChildHeightGridView(Context context, AttributeSet attrs) {\n\n        super(context, attrs);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        //在这里进行重新计算 做了判断 避免重复的多余的计算\n        if (mHeight == 0 && getChildCount()>0) {\n            fixChildHei();\n        }\n\n\n        int expandSpec;\n        if (mHeight > 0) {\n            expandSpec = MeasureSpec.makeMeasureSpec(mHeight,\n                    MeasureSpec.EXACTLY);\n        } else {\n            expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2, MeasureSpec.AT_MOST);\n        }\n        super.onMeasure(widthMeasureSpec, expandSpec);\n    }\n\n\n\n\n    private void fixChildHei()\n    {\n\n        final int PRE_GRIDVIEW_HEI= getHeight();\n\n        final int CHILD_COUNT = getChildCount();\n        if (CHILD_COUNT > 0) {\n            final int NUMCOLUMN = getNumColumns();\n            for (int i_index = 0; i_index < CHILD_COUNT / NUMCOLUMN; i_index++) {\n                int t_heimax = 0;\n                //先取得maxhei\n                for (int i_colum = 0; i_colum < NUMCOLUMN; i_colum++) {\n                    if (getChildAt(i_index * NUMCOLUMN + i_colum).getMeasuredHeight() > t_heimax) {\n                        t_heimax=getChildAt(i_index * NUMCOLUMN + i_colum).getMeasuredHeight();\n\n                    }\n                }\n\n                final int MAXHEI=t_heimax;\n                //再修正height有问题的 view\n                for (int i_colum = 0; i_colum < NUMCOLUMN; i_colum++) {\n                    if (getChildAt(i_index * NUMCOLUMN + i_colum).getMeasuredHeight() != MAXHEI) {\n                        ViewGroup.LayoutParams layoutParams=getChildAt(i_index * NUMCOLUMN + i_colum).getLayoutParams();\n                        layoutParams.height=MAXHEI;\n                        getChildAt(i_index * NUMCOLUMN + i_colum).setLayoutParams(layoutParams);\n                    }\n                }\n\n            }\n\n\n\n            //求得gridview自身的高度\n            int thishei=getChildAt(0).getMeasuredHeight()*CHILD_COUNT / NUMCOLUMN +\n                    getPaddingBottom()+\n                    getPaddingTop();\n            //计算VerticalSpacing\n            if(Build.VERSION.SDK_INT>=16)\n            {\n                thishei+=(CHILD_COUNT / NUMCOLUMN-1)*getVerticalSpacing();\n            }\n\n\n            if(PRE_GRIDVIEW_HEI>thishei) {\n                setmHeight(thishei);\n                Log.d(getClass().getSimpleName(), \"fixCHildHei\");\n            }\n\n        }\n    }\n}\n\n\n\n```\n\n#  \n代码就是这样子，看最终的效果吧！\n\n![](assets/5673bbfaab6441660a003573.PNG)\n\n#  \n目前是可以彻底解决这个问题了，那么问题来了。\n\n\n### 测试中发现：\n如果gridview刚开始visible是 gone的话 ，是不行的，所以目前如果遇到用了这个自定义控件的方法不行，那么考虑下是不是给gridiview的adapter添加数据源之前，gridview就gone掉了。\n","lang":"cn"},"__N_SSG":true}