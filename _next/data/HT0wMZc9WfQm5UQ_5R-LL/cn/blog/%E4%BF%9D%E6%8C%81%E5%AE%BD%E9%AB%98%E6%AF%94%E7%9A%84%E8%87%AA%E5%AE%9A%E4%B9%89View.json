{"pageProps":{"post":{"slug":"%E4%BF%9D%E6%8C%81%E5%AE%BD%E9%AB%98%E6%AF%94%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89View","title":"保持宽高比的自定义View.md","mdsource":"md/保持宽高比的自定义View.md","date":" 2015/10/21 00:01:33","category":"几年后回看会觉得写的太烂"},"content":"title: 保持宽高比的自定义View\ndate: 2015/10/21 00:01:33\nupdated: 2015/10/23 09:11:43\ncategories:\n- 技术\n---\n## fixheiview这个控件就是高度依据宽高比来自动变化的控件\n\n\n由于最近梯子大多都挂了 由于最近梯子大多都挂了，所以没有使用gradle构建，防止有些人需要重新下载gradle的一些jar包，而没有网络。\n代码已经传到github：[请点击我跳转](https://github.com/BruceWind/fixheiview)\n\n\n\t做这个控件的目的 就是之前有轮播图，然后轮播图的宽度肯定是要fill_parent，高度肯定以宽度为基准和一个约定的宽高比来计算得出的。\n因为如果服务器图片宽高比有问题的话，我这边界面就会很难看，所以我不能以服务器图片的宽高比来重绘。\n\n我的需求：\n> - 宽度是 fill_parent.\n> - 高度是宽度 × 约定的宽高比.\n\n这样子才是我的需求。\n虽然可以再viewpager添加数据源的时候，通过set高度的方法来控制，只是我觉得这样子手动的操作，写多次会导致代码的赘余。\n仔细思考下我发现还有其他的优点：\n\n> - set高度的方式，从代码设计模式的角度来说不是很完美。如果其他地方用到类似的控件这样子就会导致代码的赘余很厉害。\n> - 如果在listview，gridview的item的布局中也每次都set高度的话，一方面高度难以计算。\n> - 另外一方面这样子的话，会导致计算高度和布局又重新计算一次，而不单单是这个控件重新计算一次，可能父控件也重新计算一次，导致重绘次数过多，不必要的性能损耗。\n\n\n**综上：做到自定义控件里面，合适的重写父类的方法才是最好的选择。**\n\n我这里这个例子配置的是1.0的比例，上截图：\n\n![](assets/5626f6d538f4110c8f000181.PNG)\n\n“哆啦a梦！你在那？”  哈哈哈！\n\n\n好了，废话说完了。上代码：\n\n\n### 1.自定义属性：\n\n\n``` xml\n  <declare-styleable name=\"FixHeiImageView\">\n        <attr name=\"whratio\" format=\"float\" />\n    </declare-styleable> \n\n```\n\n### 2.控件\n\n``` java\n\n\npublic class FixHeiImageView extends ImageView\n{\n\tprivate double wh_ratio=0.0;\n\n\tpublic FixHeiImageView(Context context)\n\t{\n\t\tsuper(context);\n\t\twh_ratio = 2.0;\n\t}\n\t\n\tpublic FixHeiImageView(Context context, double mWh_ratio)\n\t{\n\t\tsuper(context);\n\n\t\tthis.wh_ratio = mWh_ratio;\n\t}\n\n\tpublic FixHeiImageView(Context context, AttributeSet attrs)\n\t{\n\t\tsuper(context, attrs);\n\n\t\tTypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FixHeiImageView);\n\t\twh_ratio = typedArray.getFloat(R.styleable.FixHeiImageView_whratio, (float) 1.0);\n\t\ttypedArray.recycle();\n\t}\n\t\n\tpublic FixHeiImageView(Context context, AttributeSet attrs, int defStyle) {\n\t\tsuper(context, attrs, defStyle);\n\n\t\tTypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FixHeiImageView);\n\t\twh_ratio = typedArray.getFloat(R.styleable.FixHeiImageView_whratio, (float) 1.0);\n\t\ttypedArray.recycle();\n\t}\n\t\n\t@Override\n\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)\n\t{\n\t\t// 父容器传过来的宽度方向上的模式\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        // 父容器传过来的高度方向上的模式\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n\n        // 父容器传过来的宽度的值\n        int width = MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft()\n                - getPaddingRight();\n        // 父容器传过来的高度的值\n        int height = MeasureSpec.getSize(heightMeasureSpec) - getPaddingBottom()\n                - getPaddingTop();\n\n            height = (int) (width / wh_ratio + 0.5f);\n            heightMeasureSpec = MeasureSpec.makeMeasureSpec(height,\n                    MeasureSpec.EXACTLY);\n            super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\t}\n}\n\n```\n这里代码的逻辑很简单，也有了注释， 我就不再详细解释了。这里是把高度的计算放到onMeasure中了，减少了多次计算和重绘的性能浪费。\n\n\n> - 我这里只是重写了ImageView，如果还有别的需求还可以再改下这个类，为你所用。\n> - 比如你需要重写Linearlayout，重写其他layout之类的。","lang":"cn"},"__N_SSG":true}