{"pageProps":{"post":{"slug":"%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96%E5%88%97%E8%A1%A8%E9%A1%B5%E5%8D%A1%E9%A1%BF%E7%9A%84%E7%BB%8F%E5%8E%86","title":"一次优化列表页卡顿的经历.md","mdsource":"md/一次优化列表页卡顿的经历.md","date":" 2016/03/24 21:20:01","category":"几年后回看会觉得写的太烂"},"content":"title: 一次优化列表页卡顿的经历\ndate: 2016/03/24 21:20:01\nupdated: 2016/07/14 22:58:22\ncategories:\n- 技术\n---\n    写下这篇文章的日期是2016年4月初。当时来到公司，项目之前是外包出去的，代码乱糟糟的，需要重构掉，摆在面前的问题不是重构项目，而是一些列表页的紧急的性能优化。\n\n## 1.先优化item的层级\n\n    其实层级只要不是太深的话，比如5层，6层，对性能的差别在中等性能的机器上几乎看不出来的，但是想要做到 极致,我就得死扣细节，原来代码是有4层的，其实有一点点接近可优化的范围了，我把原来的4层降到1层。1层的话在item的话，在cpu进行计算测量的时候就速度很快了。\n\n### 下面是我用DDMS去查看***某厂***和***我厂***的列表的控件层级对比。\n# \n如图：某厂的列表的item的层级，**三层**：`  Grid>Linear>Frame>Rela`\n![某厂的列表的item的层级](assets/listper1.png)\n# \n我厂 的列表页的`优化后`的item的层级，**一层**：` Grid>Rela `\n# \n![我厂的列表的item的层](assets/listper2.png)\n其实敌台列表页卡顿也是严重，而且肉眼可见的控件，敌台比我台少了一个圆形头像的控件，bitmap占大头，虽然敌台有几个textview，但是textview本身就几乎没什么可以性能优化的东西了。但是我依旧要做的比敌台还要流畅。\n#  \n-------------------\n\n## 2.优化**OVERDRAW**过渡绘制的问题。\n旧的代码，先来看下listview的getview方法的代码：\n```\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        if (convertView == null) {\n            convertView = LayoutInflater.from(context).inflate(R.layout.item_live_adapter, parent, false);\n        }\n        LinearLayout layout_item_live = BaseViewHolder.get(convertView, R.id.layout_item_live);\n        if (position % 2 == 0) {//重点在于这里\n            layout_item_live.setPadding(20, 20, 10, 0);\n        } else if (position % 2 == 1) {\n            layout_item_live.setPadding(10, 20, 20, 0);\n        }\n        ImageView iv_item_live_cover = BaseViewHolder.get(convertView, R.id.iv_item_live_cover);\n        TextView tv_live_hostname = BaseViewHolder.get(convertView, R.id.tv_live_hostname);\n        TextView tv_item_live_viewernum = BaseViewHolder.get(convertView, R.id.tv_item_live_viewernum);\n        TextView tv_item_live_title = BaseViewHolder.get(convertView, R.id.tv_item_live_title);\n        CircleImageView iv_item_recycle_host_head = BaseViewHolder.get(convertView, R.id.iv_item_recycle_host_head);\n        bitmapUtils.configDefaultLoadFailedImage(R.mipmap.live_default);\n        bitmapUtils.configDefaultLoadingImage(R.mipmap.live_default);\n        bitmapUtils.display(iv_item_live_cover, list_info.get(position).get(\"thumb\").toString());\n        bitmapUtils.display(iv_item_recycle_host_head , list_info.get(position).get(\"avatar\").toString());\n        tv_live_hostname.setText(list_info.get(position).get(\"nick\").toString());\n        int view = Integer.parseInt(list_info.get(position).get(\"view\").toString());\n        if(view > 10000){\n            BigDecimal b1 = new BigDecimal(view);\n            BigDecimal b2 = new BigDecimal(10000);\n            tv_item_live_viewernum.setText(b1.divide(b2,1,BigDecimal.ROUND_HALF_UP).doubleValue()+\"W\");\n        }else{\n            tv_item_live_viewernum.setText(view + \"\");\n        }\n        tv_item_live_title.setText(list_info.get(position).get(\"title\").toString());\n        return convertView;\n    }\n```\n\n`setPadding`理论上来说会出发`childMeasure`方法，然后就是一堆的UI线程的不断去计算的东西。然后子层级和自控件也不是特别少，所以这里问题也是很大啊！！\n\n\n# 用traceview追踪卡顿的过程CPU耗时在哪里比较多\n\n旧的代码运行时，滚动列表，为了公平，在listview上下滚动过之后，保证有了图片的内存缓存之后，清理下log，再滚动抓取的截图如下\n![](assets/traceview1.png)\nui线程只有空闲的时候才会去循环loop。如果我的list滚动的性能不好loop的占用的百分比肯定低。目前，Looper的占比只有50%左右。\n![](assets/traceview2.png)\n往下翻，请仔细看30那行，虽然我选中的时25行！！！\n![](assets/traaceview3.png)\n30这行指向了我们自己的com.maimiao...的一个自定义控件，占了35%的cpu耗时，所以这里有点严重了。如果去除这35%，基本上也是接近于90%的loope。\n# \n## 贴出traceview指向的这个自定义控件的一些方法\n\n`RoundImageViewByXfermode`这个类是旧的代码里用于做圆角而使用的自定义控件。其实实现圆角有三种方案，我按性能高低排序往下说，\n>- 第一种，画矩形图，不修圆角，使用和背景色一致OVERCOLOR盖住四个角\n>- 第二种，bitmapShader。\n>- 第三种，Xfermode。旧的代码正是用的这种。\n```\n\n\t@SuppressLint(\"DrawAllocation\")\n\t@Override\n\tprotected void onDraw(Canvas canvas)\n\t{\n\t\t//在缓存中取出bitmap\n\t\tBitmap bitmap = mWeakBitmap == null ? null : mWeakBitmap.get();\n\n\t\tif (null == bitmap || bitmap.isRecycled())\n\t\t{\n\t\t\t//拿到Drawable\n\t\t\tDrawable drawable = getDrawable();\n\t\t\t\n\n\t\t\tif (drawable != null)\n\t\t\t{\n\t\t\t\t//获取drawable的宽和高\n\t\t\t\tint dWidth = drawable.getIntrinsicWidth();\n\t\t\t\tint dHeight = drawable.getIntrinsicHeight();\n\t\t\t\t//创建bitmap\n\t\t\t\tbitmap = Bitmap.createBitmap(getWidth(), getHeight(),\n\t\t\t\t\t\tConfig.ARGB_8888);\n\t\t\t\tfloat scale = 1.0f;\n\t\t\t\t//创建画布\n\t\t\t\tCanvas drawCanvas = new Canvas(bitmap);\n\t\t\t\t//按照bitmap的宽高，以及view的宽高，计算缩放比例；因为设置的src宽高比例可能和imageview的宽高比例不同，这里我们不希望图片失真；\n\t\t\t\tif (type == TYPE_ROUND)\n\t\t\t\t{\n\t\t\t\t\t// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；\n\t\t\t\t\tscale = Math.max(getWidth() * 1.0f / dWidth, getHeight()\n\t\t\t\t\t\t\t* 1.0f / dHeight);\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tscale = getWidth() * 1.0F / Math.min(dWidth, dHeight);\n\t\t\t\t}\n\t\t\t\t//根据缩放比例，设置bounds，相当于缩放图片了\n\t\t\t\tdrawable.setBounds(0, 0, (int) (scale * dWidth),\n\t\t\t\t\t\t(int) (scale * dHeight));\n\t\t\t\tdrawable.draw(drawCanvas);\n\t\t\t\tif (mMaskBitmap == null || mMaskBitmap.isRecycled())\n\t\t\t\t{\n\t\t\t\t\tmMaskBitmap = getBitmap();\n\t\t\t\t}\n\t\t\t\t// Draw Bitmap.\n\t\t\t\tmPaint.reset();\n\t\t\t\tmPaint.setFilterBitmap(false);\n\t\t\t\tmPaint.setXfermode(mXfermode);\n\t\t\t\t//绘制形状\n\t\t\t\tdrawCanvas.drawBitmap(mMaskBitmap, 0, 0, mPaint);\n\t\t\t\tmPaint.setXfermode(null);\n\t\t\t\t//将准备好的bitmap绘制出来\n\t\t\t\tcanvas.drawBitmap(bitmap, 0, 0, null);\n\t\t\t\t//bitmap缓存起来，避免每次调用onDraw，分配内存\n\t\t\t\tmWeakBitmap = new WeakReference<Bitmap>(bitmap);\n\t\t\t}\n\t\t}\n\t\t//如果bitmap还存在，则直接绘制即可\n\t\tif (bitmap != null)\n\t\t{\n\t\t\tmPaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(bitmap, 0.0f, 0.0f, mPaint);\n\t\t\treturn;\n\t\t}\n\n\t}\n\t/**\n\t * 绘制形状\n\t * @return\n\t */\n\tpublic Bitmap getBitmap()\n\t{\n\t\tBitmap bitmap = Bitmap.createBitmaps(getWidth(), getHeight(),\n\t\t\t\tConfig.ARGB_8888);\n\t\tCanvas canvas = new Canvas(bitmap);\n\t\tPaint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\tpaint.setColor(Color.BLACK);\n\n\t\tif (type == TYPE_ROUND)\n\t\t{\n\t\t\tcanvas.drawRoundRect(new RectF(0, 0, getWidth(), getHeight()),\n\t\t\t\t\tmBorderRadius, mBorderRadius, paint);\n\t\t} else\n\t\t{\n\t\t\tcanvas.drawCircle(getWidth() / 2, getWidth() / 2, getWidth() / 2,\n\t\t\t\t\tpaint);\n\t\t}\n\n\t\treturn bitmap;\n\t}\n```\n\n    如上，代码明显性能很差，createBitmap，Bitmap的色彩用的也是ARGB_8888，内存消耗也很大，同时还频繁使用setXfermode模式，这些东西都在UI线程走，性能极差。\n为了证明traceview没骗我，我也没冤枉他，我把自定义控件改成了imageview，padding也去掉，性能确实提升了很高。\n# \n为了解决这些问题我打算用fresco去完成这些工作，fresco的老东家把android性能优化做到了极致，研究了好多年，也贡献了很多文献资料开源的东西。\n## fresco，对于圆角和圆形有两种方案\n\n>- 第一种，OVERLAY_COLOR,就是正常展示一张正方形图，圆角的地方用非透明颜色绘制遮挡的方案，来完成，这种性能极高。但是，如果碰到控件背景非透明的情况，就没法用了。\n\n>- 第二种，BITMAP_ONLY,原型图他是用BitmapShader来完成性能不怎样，但是fresco只能尽量帮你做到不重复创建bitmap之类的性能问题，来实现圆形或者圆角。\n    \n    fresco绝对不用xfermode方案。\n# \n## 使用SystemClock去抓取getView或者bindHolder方法之行的耗时\n\n贴出优化之前的getview中代码段的耗时，为了公平，不把LayoutInflat这行代码纪录进来。因为后面我打重构这个list之后，我用的是RecyclerView，bind方法和create方法是分开的，我要保证公平。\n![](assets/log0.png)\n明显这个旧的getView的代码已经明显出现耗时的抖动问题了，重构之后的那段`BindHolder`代码的cpu耗时标准的在2-4ms之间,后面会贴出截图。旧的代码他猛起来居然可以跑到7，其实有些地方截图没截到，还有10ms的，一个getView都10ms，那一些log看不到的地方再算下来会更加严重的，这就是为什么这个list这么卡的原因。\n# \n    android屏幕刷新频率是16ms，如果一旦UI线程繁忙超过16ms，那么就很容易被看出卡顿，当然页面静止的情况下页面卡顿的话也是很难看出来，因为卡是静止的，不卡也是静止的。但是到列表页上之后，就不同了，到了列表页，很多问题都容易被凸显出来，滚动不流畅，明显掉帧，这些都要去仔细找问题。\n# \n为了找到这段getView中cpu耗时抖动的问题，我先猜测一些第三方的东西，那就是xutils了，其次时BaseViewHolder这个查找view的代码，他内部是SparseArray，理论上来说性能也是蛮高的，所以先从xutils下手，我不能没有证据的责怪xutils，所以我再次打log在xutils那三四行代码上，不抓取其他的代码耗时。\n# \n为了保证公平，我多上下滚动几遍，等xutils把图片都缓存到内存中之后，我清掉日志，开始滚动，看到的数据是这样子。\n![](assets/log1.png)\n确实很明显，这里把计时夹在xutils的几行代码得前后，居然有两次他cpu耗时到了4，安静下来的时候也可以是0,所以，无疑这个地方xutils难逃干系。\n#  \n下面是重构方案\n\n# 重构之后\n重构之后这里圆角和圆形都使用fresco来完成这些，圆角的大图由于背景色是白色就可以用OVERLAY_COLOR，那个圆形头像背景需要透明，所以还是得BITMAP_ONLY模式。\n\n```\n    //贴出重构之后的bindHolder代码\n    @Override\n    public void onBindItemViewHolder(LiveFragholder holder, final int position) {\n\n\n        String url=getList().get(position).get(\"avatar\").toString()+\"\";\n\n        FrescoUtils.displayAvatar(holder.iv_item_recycle_host_head,url);\n        FrescoUtils.displayUrl(holder.iv_item_live_cover, getList().get(position).get(\"thumb\").toString());\n\n\n        holder.tv_live_hostname.setText(getList().get(position).get(\"nick\").toString());\n        int view = Integer.parseInt(getList().get(position).get(\"view\").toString());\n        if(view > 10000){\n            BigDecimal b1 = new BigDecimal(view);\n            BigDecimal b2 = new BigDecimal(10000);\n            holder.tv_item_live_viewernum.setText(b1.divide(b2,1,BigDecimal.ROUND_HALF_UP).doubleValue()+\"W\");\n        }else{\n            holder.tv_item_live_viewernum.setText(view + \"\");\n        }\n        holder.tv_item_live_title.setText(getList().get(position).get(\"title\").toString());\n\n        final Context context=holder.iv_item_live_cover.getContext();\n        holder.iv_item_live_cover.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                HashMap<String,String> mob_map = new HashMap<>();\n                //因为某些圆形这里还在使用hasmap\n                mob_map.put(\"position\",position + \"\");\n                MobclickAgent.onEvent(context, UmengCollectConfig.ZB_FL,mob_map);\n                Bundle bundle = new Bundle();\n                bundle.putString(\"uid\", getList().get(position).get(\"uid\").toString());\n                Intent intent = new Intent();\n                intent.setClass(context, TheLiveActivity.class);\n                intent.putExtras(bundle);\n                context.startActivity(intent);\n            }\n        });\n    }\n\n```\n\n\n来看下优化之后的onBinderItem的全部代码，滚动过程的时traceview抓取的数据。\n![](assets/traceview4.png)\n明显看到一个点，90.2%的耗时都在Looper.loop上。这说明是正常的，上面说了ui线程只有空闲的时候才会去循环的loop。如果我的list滚动的性能不好loop的占用的百分比肯定低。\n\n\n# \n在我的`BindHoder`代码开头做一个毫秒级时间戳的记录，在结尾处也做个纪录，对比两个时间戳的差值，查看具体我在`BindHoder`中的代码耗时。\n![](assets/log2.png)\ncpu耗时标准的在2-4ms之间。非常的稳定，没有乱飘的现象。\n\n这个时间比之前得一个时间长了点，没问题的，这个是抓取全部得onBindItem得代码，上面只是截取 xutils载入图片的几行代码而已。所以这里全部的代码已经顶了原来旧的代码里面xutils的几行了。cpu耗时提升了很多很多。前面的还要前面那张耗时的log才是正确的getView里全部得代码耗时统计。\n\n-----------------\n# 简直完美！！！！对比下敌台的列表页，肉眼明显可见的敌台列表页卡顿比我们还严重，而且对方的item还比我们多了一个圆形头像的空间。终于可以拍着膀子说我们比敌台性能好。\n\n\n","lang":"cn"},"__N_SSG":true}