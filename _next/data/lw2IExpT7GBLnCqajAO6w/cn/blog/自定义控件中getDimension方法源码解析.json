{"pageProps":{"post":{"slug":"自定义控件中getDimension方法源码解析","title":"自定义控件中getDimension方法源码解析.md","mdsource":"md/自定义控件中getDimension方法源码解析.md","date":" 2015/09/16 23:01:22","category":"几年后回看会觉得写的太烂"},"content":"title: 自定义控件中getDimension方法源码解析\ndate: 2015/09/16 23:01:22\nupdated: 2016/02/25 00:29:16\ncategories:\n- 技术\n---\n\ngetDimension() \ngetDimensionPixelOffset() \n两个方法的区别在哪？ \n\n# \n\n先贴出这个方法的源码：（方法的理解，我写进注释里了）\n\n``` java\n\n//getDimension\n\t public float getDimension(int index, float defValue) {\n\t \n\t\t......//省略部分判断的代码\n\t\t\t\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        final int type = data[index+AssetManager.STYLE_TYPE];\n        if (type == TypedValue.TYPE_NULL) {\n\t        //空的时候返回默认值\n            return defValue;\n        } else if (type == TypedValue.TYPE_DIMENSION) {\n\t        //类型正确的时候往下走\n            return TypedValue.complexToDimension(\n                data[index+AssetManager.STYLE_DATA], mMetrics);\n        } else if (type == TypedValue.TYPE_ATTRIBUTE) {\n\t        //类型不正确的时候抛出异常\n            throw new RuntimeException(\"Failed to resolve attribute at index \" + index);\n        }\n\t\t......\n\n    }\n\n//getDimensionPixelOffset\npublic int getDimensionPixelOffset(int index, int defValue) {\n\n\t\t......\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        final int type = data[index+AssetManager.STYLE_TYPE];\n        if (type == TypedValue.TYPE_NULL) {\n            return defValue;\n        } else if (type == TypedValue.TYPE_DIMENSION) {\n            return TypedValue.complexToDimensionPixelOffset(\n                data[index+AssetManager.STYLE_DATA], mMetrics);\n        } else if (type == TypedValue.TYPE_ATTRIBUTE) {\n            throw new RuntimeException(\"Failed to resolve attribute at index \" + index);\n        }\n\t\t......\n\n    }\n\n```\n这两个方法的源代码呢，似乎都差不多的东西。\n\t\n\t区别就在于：一个是执行了TypedValue.complexToDimension 一个是执行了TypedValue.complexToDimensionPixelOffse。\n\n等会再看complexToDimension方法。我们先来看下mData这个字段。\n# \n由于再getDimension之前，我们调用了context.obtainStyleAttr()，mData被追踪到了这里。\n那么我们看下这个方法的代码:\n``` java\n\n public TypedArray obtainStyledAttributes(AttributeSet set,\n                int[] attrs, int defStyleAttr, int defStyleRes) {\n            final int len = attrs.length;\n            final TypedArray array = TypedArray.obtain(Resources.this, len);\n\n            // XXX note that for now we only work with compiled XML files.\n            // To support generic XML files we will need to manually parse\n            // out the attributes from the XML file (applying type information\n            // contained in the resources and such).\n            final XmlBlock.Parser parser = (XmlBlock.Parser)set;\n            AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes,\n                    parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);\n\n            array.mTheme = this;\n            array.mXml = parser;\n\n            if (false) {\n                int[] data = array.mData;\n                \n                System.out.println(\"Attributes:\");\n                String s = \"  Attrs:\";\n                int i;\n                for (i=0; i<set.getAttributeCount(); i++) {\n                    s = s + \" \" + set.getAttributeName(i);\n                    int id = set.getAttributeNameResource(i);\n                    if (id != 0) {\n                        s = s + \"(0x\" + Integer.toHexString(id) + \")\";\n                    }\n                    s = s + \"=\" + set.getAttributeValue(i);\n                }\n                System.out.println(s);\n                s = \"  Found:\";\n                TypedValue value = new TypedValue();\n                for (i=0; i<attrs.length; i++) {\n                    int d = i*AssetManager.STYLE_NUM_ENTRIES;\n                    value.type = data[d+AssetManager.STYLE_TYPE];\n                    value.data = data[d+AssetManager.STYLE_DATA];\n                    value.assetCookie = data[d+AssetManager.STYLE_ASSET_COOKIE];\n                    value.resourceId = data[d+AssetManager.STYLE_RESOURCE_ID];\n                    s = s + \" 0x\" + Integer.toHexString(attrs[i])\n                        + \"=\" + value;\n                }\n                System.out.println(s);\n            }\n\n            return array;\n        }\n\n```\n\n\n\n我们直接就看 TypedValue.complexToDimension(......);\n        这个static方法吧?\n\n# \n上代码 :\n\n``` java\n\n//TypeArray 内 getDimension方法调用了这里\npublic static float complexToDimension(int data, DisplayMetrics metrics)\n    {\n        return applyDimension(\n            (data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK,\n            complexToFloat(data),\n            metrics);\n    }\n\n\n//TypeArray 内 getDimensionPixelOffset方法调用了这里\n public static int complexToDimensionPixelOffset(int data,\n            DisplayMetrics metrics)\n    {\n        return (int)applyDimension(\n                (data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK,\n                complexToFloat(data),\n                metrics);\n    }\n\n```\n\n好了大概逻辑就是这样子 :\n\t\tgetDimension                  -> complexToDimension\n\t\tgetDimensionPixelOffset -> complexToDimensionPixelOffset\n\n其中， (data>>COMPLEX_UNIT_SHIFT) & COMPLEX_UNIT_MASK的意思是将该int值与上0xf，以获取其最低4位，这4位是**单位**。而complexToFloat则是使用该int值的最高24位当作数值，4-7位作为radix，进行计算，转成float。\n\n而这个complexToDimension与complexToDimensionPixelOffset方法内的代码一样的,只是一个被强制转类型为int了,一个没有被强制转。\n\n那么，getDimension与getDimensionPixelOffset得到的值应该是几乎相等的，误差就在于类型强转。  \n所以可得到官网提到的这个“原始像素带有偏移量”，这个词或许他的意思就是比较精确地像素和不太精确地，但是这里误差是小于1像素的，那么这个0.1的精确好像作用不大啊！\n\t\n\t这里我也无法理解为何这个不到1像素的误差为何还要区分出来两个方法，可能有些地方为了这些小的不到一个像素的多余的位置在对于一个布局是很重要的，如果一个横向分辨率是720的手机，父控件有横向有两个子控件，也是用这种dp属性的计算，最后计算得出的一个是359.6一个是360.4，这里子控件显示的时候肯定是知道自己的宽度的整数即可，但是父控件或许是需要知道他们的带小数点的值来求得总和的实际宽度。\n\n\n\n然后他指向了applyDimension(....)方法,我们看下applyDimension()方法的代码:\n\n``` java\n\npublic static float applyDimension(int unit, float value,\n                                       DisplayMetrics metrics)\n    {\n        switch (unit) {\n        case COMPLEX_UNIT_PX:\n            return value;\n        case COMPLEX_UNIT_DIP:\n            return value * metrics.density;\n        case COMPLEX_UNIT_SP:\n            return value * metrics.scaledDensity;\n        case COMPLEX_UNIT_PT:\n            return value * metrics.xdpi * (1.0f/72);\n        case COMPLEX_UNIT_IN:\n            return value * metrics.xdpi;\n        case COMPLEX_UNIT_MM:\n            return value * metrics.xdpi * (1.0f/25.4f);\n        }\n        return 0;\n    }\n\n```\napplyDimension的第一个参数代表他是什么单位，然后根据不同的单位返回相同的值。\n\n\n在applyDimension中根据单位的不同，将float乘上不同的系数。如dip/dp需乘上屏幕系数，sp需乘上字号的缩放系数，pt、in、mm等也是根据相应的算法进行换算。\n\n\treturn value * metrics.density; 这个代码跟我们平时手动写dp2px方法的代码几乎是一样的，我们平时可能是为了误差的问题在后面加上0.5*density。\n\n其实这里有有一点要提的是：dp px  mm 等，在系统中都是以 \"数值+单位\" 在系统中存储的。\n\n比如：\n``` xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n<resources>  \n    <dimen name=\"zl_def_indicator_radius\">4dp</dimen>  \n    <dimen name=\"zl_def_font_size\">16sp</dimen>  \n</resources>  \n\n```\n这种存起来的时候都是以 \"数值+单位\" 存储的.\n\nAndroid的Resoureces类的getDimension方法，对于不同的dimension，在使用getValue获取到对应的int值之后，会通过TypedValue的complextoDimension方法将其转换为float。\n\n# \n\n本文涉及到的github的android源码，地址如下：\n\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/Context.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/Resources.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/AssetManager.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/util/TypedValue.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/TypedArray.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/Resources.java","lang":"cn"},"__N_SSG":true}