<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1, width=device-width"/><meta name="emotion-insertion-point" content=""/><title>Java局部字段释放规则探索.md<!-- --> - BruceWind&#x27;s Blog</title><meta name="description" content="Java局部字段释放规则探索.md - 几年后回看会觉得写的太烂"/><meta property="og:title" content="Java局部字段释放规则探索.md"/><meta property="og:type" content="article"/><meta property="article:published_time" content=" 2017/03/01 19:44:44"/><meta name="next-head-count" content="8"/><meta charSet="utf-8"/><meta name="keywords" content="NDK,JNI,Android Dev,android,androidyuan,性能优化,Linux,developer"/><meta name="description" content="BruceWind&#x27;s personal blog - Android development, Linux, and more."/><meta name="robots" content="index,follow"/><meta name="google" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="author" content="bruce"/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#000000"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LGE1LT9YJG"></script><script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', 'G-LGE1LT9YJG');
              </script><style data-emotion="mui-style-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><style data-emotion="mui-style 17ro72p 1cp6o32 79elbk 1qo0fs4 1uf4bbi 1m9pwf3 19gndve 1ju1kxc k1u9gz 6xugel vubbuv gtvj52 1x1vlev vax71z">.mui-style-17ro72p{width:100%;min-height:100vh;background-color:#fff;padding:16px;}.mui-style-1cp6o32{background-color:#fff;color:rgba(0, 0, 0, 0.87);-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12);padding:24px;}.mui-style-79elbk{position:relative;}.mui-style-1qo0fs4{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;width:58px;height:38px;overflow:hidden;padding:12px;box-sizing:border-box;position:relative;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;z-index:0;vertical-align:middle;width:62px;height:34px;padding:7px;margin:8px;}@media print{.mui-style-1qo0fs4{-webkit-print-color-adjust:exact;color-adjust:exact;}}.mui-style-1qo0fs4 .MuiSwitch-switchBase{margin:1px;padding:0;-webkit-transform:translateX(6px);-moz-transform:translateX(6px);-ms-transform:translateX(6px);transform:translateX(6px);}.mui-style-1qo0fs4 .MuiSwitch-switchBase.Mui-checked{color:#fff;-webkit-transform:translateX(22px);-moz-transform:translateX(22px);-ms-transform:translateX(22px);transform:translateX(22px);}.mui-style-1qo0fs4 .MuiSwitch-switchBase.Mui-checked .MuiSwitch-thumb:before{background-image:url('data:image/svg+xml;utf8,<?xml version="1.0" ?><svg height="20" width="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g><path d="M0 0h24v24H0z" fill="none"/><path fill="white" d="M12 19a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm-5.5 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm11 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zM13 2v2h6v2h-1.968a18.222 18.222 0 0 1-3.621 6.302 14.685 14.685 0 0 0 5.327 3.042l-.536 1.93A16.685 16.685 0 0 1 12 13.726a16.696 16.696 0 0 1-6.202 3.547l-.536-1.929a14.7 14.7 0 0 0 5.327-3.042 18.077 18.077 0 0 1-2.822-4.3h2.24A16.031 16.031 0 0 0 12 10.876a16.168 16.168 0 0 0 2.91-4.876L5 6V4h6V2h2z"/></g></svg>');}.mui-style-1qo0fs4 .MuiSwitch-switchBase.Mui-checked+.MuiSwitch-track{opacity:1;background-color:#aab4be;}.mui-style-1qo0fs4 .MuiSwitch-thumb{background-color:#001e3c;width:32px;height:32px;}.mui-style-1qo0fs4 .MuiSwitch-thumb:before{content:'';position:absolute;width:100%;height:100%;left:0;top:0;background-repeat:no-repeat;-webkit-background-position:center;background-position:center;background-image:url('data:image/svg+xml;utf8,<?xml version="1.0" ?><svg height="20" width="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none" /><path fill="white" d="M14 10h2v.757a4.5 4.5 0 0 1 7 3.743V20h-2v-5.5c0-1.43-1.175-2.5-2.5-2.5S16 13.07 16 14.5V20h-2V10zm-2-6v2H4v5h8v2H4v5h8v2H2V4h10z"/></svg>');}.mui-style-1qo0fs4 .MuiSwitch-track{opacity:1;background-color:#aab4be;border-radius:10px;}.mui-style-1uf4bbi{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;padding:9px;border-radius:50%;position:absolute;top:0;left:0;z-index:1;color:#fff;-webkit-transition:left 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,-webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:left 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,transform 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;}.mui-style-1uf4bbi::-moz-focus-inner{border-style:none;}.mui-style-1uf4bbi.Mui-disabled{pointer-events:none;cursor:default;}@media print{.mui-style-1uf4bbi{-webkit-print-color-adjust:exact;color-adjust:exact;}}.mui-style-1uf4bbi.Mui-checked{-webkit-transform:translateX(20px);-moz-transform:translateX(20px);-ms-transform:translateX(20px);transform:translateX(20px);}.mui-style-1uf4bbi.Mui-disabled{color:#f5f5f5;}.mui-style-1uf4bbi.Mui-checked+.MuiSwitch-track{opacity:0.5;}.mui-style-1uf4bbi.Mui-disabled+.MuiSwitch-track{opacity:0.12;}.mui-style-1uf4bbi .MuiSwitch-input{left:-100%;width:300%;}.mui-style-1uf4bbi:hover{background-color:rgba(0, 0, 0, 0.04);}@media (hover: none){.mui-style-1uf4bbi:hover{background-color:transparent;}}.mui-style-1uf4bbi.Mui-checked{color:#1976d2;}.mui-style-1uf4bbi.Mui-checked:hover{background-color:rgba(25, 118, 210, 0.04);}@media (hover: none){.mui-style-1uf4bbi.Mui-checked:hover{background-color:transparent;}}.mui-style-1uf4bbi.Mui-checked.Mui-disabled{color:rgb(167, 202, 237);}.mui-style-1uf4bbi.Mui-checked+.MuiSwitch-track{background-color:#1976d2;}.mui-style-1m9pwf3{cursor:inherit;position:absolute;opacity:0;width:100%;height:100%;top:0;left:0;margin:0;padding:0;z-index:1;}.mui-style-19gndve{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);background-color:currentColor;width:20px;height:20px;border-radius:50%;}.mui-style-1ju1kxc{height:100%;width:100%;border-radius:7px;z-index:-1;-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;background-color:#000;opacity:0.38;}.mui-style-k1u9gz{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:500;font-size:0.875rem;line-height:1.75;letter-spacing:0.02857em;text-transform:uppercase;min-width:64px;padding:6px 8px;border-radius:4px;-webkit-transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:#1976d2;margin-bottom:16px;}.mui-style-k1u9gz::-moz-focus-inner{border-style:none;}.mui-style-k1u9gz.Mui-disabled{pointer-events:none;cursor:default;}@media print{.mui-style-k1u9gz{-webkit-print-color-adjust:exact;color-adjust:exact;}}.mui-style-k1u9gz:hover{-webkit-text-decoration:none;text-decoration:none;background-color:rgba(25, 118, 210, 0.04);}@media (hover: none){.mui-style-k1u9gz:hover{background-color:transparent;}}.mui-style-k1u9gz.Mui-disabled{color:rgba(0, 0, 0, 0.26);}.mui-style-6xugel{display:inherit;margin-right:8px;margin-left:-4px;}.mui-style-6xugel>*:nth-of-type(1){font-size:20px;}.mui-style-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}.mui-style-gtvj52{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:2.125rem;line-height:1.235;letter-spacing:0.00735em;margin-bottom:0.35em;}.mui-style-1x1vlev{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;margin-bottom:0.35em;color:rgba(0, 0, 0, 0.6);}.mui-style-vax71z{margin:0;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;border-width:0;border-style:solid;border-color:rgba(0, 0, 0, 0.12);border-bottom-width:thin;margin-top:16px;margin-bottom:16px;}</style><link rel="preload" href="/_next/static/css/345ff263c1768dbb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/345ff263c1768dbb.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-6ef43a8d4a395f49.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-5b2299ded1a46c83.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4f0aaa3a6ba99024.js" defer=""></script><script src="/_next/static/chunks/34-75ae01f5fa578a9a.js" defer=""></script><script src="/_next/static/chunks/995-a5f98cc3a4d14286.js" defer=""></script><script src="/_next/static/chunks/771-702e6dcd51d5534b.js" defer=""></script><script src="/_next/static/chunks/pages/%5Blang%5D/blog/%5Bslug%5D-beca72dadde25cc7.js" defer=""></script><script src="/_next/static/GHV3Hdifg6RQFG6pfrsvS/_buildManifest.js" defer=""></script><script src="/_next/static/GHV3Hdifg6RQFG6pfrsvS/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="MuiBox-root mui-style-17ro72p"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation3 mui-style-1cp6o32"><div class="MuiBox-root mui-style-79elbk"><div style="position:fixed;top:22px;right:15px;z-index:1300"><span class="MuiSwitch-root MuiSwitch-sizeMedium mui-style-1qo0fs4"><span class="MuiButtonBase-root MuiSwitch-switchBase MuiSwitch-colorPrimary Mui-checked PrivateSwitchBase-root MuiSwitch-switchBase MuiSwitch-colorPrimary Mui-checked Mui-checked mui-style-1uf4bbi"><input class="PrivateSwitchBase-input MuiSwitch-input mui-style-1m9pwf3" type="checkbox" checked=""/><span class="MuiSwitch-thumb mui-style-19gndve"></span></span><span class="MuiSwitch-track mui-style-1ju1kxc"></span></span></div><a class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorPrimary MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorPrimary mui-style-k1u9gz" tabindex="0" href="/cn/"><span class="MuiButton-icon MuiButton-startIcon MuiButton-iconSizeMedium mui-style-6xugel"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-style-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ArrowBackIcon"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"></path></svg></span>返回列表</a><h1 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom mui-style-gtvj52">Java局部字段释放规则探索.md</h1><p class="MuiTypography-root MuiTypography-body2 MuiTypography-gutterBottom mui-style-1x1vlev">几年后回看会觉得写的太烂<!-- --> | <!-- --> 2017/03/01 19:44:44</p><hr class="MuiDivider-root MuiDivider-fullWidth mui-style-vax71z"/><div class="markdown-body"><p>title: Java局部字段释放规则探索
date: 2017/03/01 19:44:44
updated: 2017/04/27 10:49:16
categories:</p>
<ul>
<li>技术</li>
</ul>
<hr/>
<p>可能很多人，对局部字段释放的规则一头雾水，只是单纯的知道 只要代码作用域结束了，那么作用域内的所有字段都可以被释放。
在读《深入理解Java虚拟机》的时候，发现并非如此，其中的规则蛮复杂，堆内存和栈内存规则区别很大。</p>
<h3>关于堆内存和栈内存：</h3>
<blockquote>
<p>节选自《深入理解Java虚拟机》
经常有人把Java内存区分为堆内存( Heap )和栈内存( Stack),这种分法比较粗
糙 ,Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面会专门讲述,而所指的“栈”就是现在讲的虚拟机栈,或者说是虚拟机栈中局部变量表部分。</p>
</blockquote>
<p>所以我们写代码测试一下，试着找寻释放规则。</p>
<pre><code class="language-java">public class TestModel {

    //这个值希望设置为Runtime.getRuntime().maxMemory()/2 的值,这样子内存中一旦有一个没有被释放则直接OOM
    final byte[] mBytes = new byte[getXmxHalf()];//

    @Override
    protected void finalize() throws Throwable {
        Log.d(&quot;TestModel&quot;,&quot;finalize()&quot;); //当内存被释放时 我可以从日志中看到
        super.finalize();
    }

    //内存的最大值取决于 JVM的xmx参数配置 所以这里取一半，只要内存中有两个  即可发生OOM
    public static int getXmxHalf()
    {
        return (int)(Runtime.getRuntime().maxMemory()/2);
    }
}


</code></pre>
<p>###上面这些代码中有两点需要说明：
1.finalize是什么： 这个是GC管理器释放一个对象时调用的方法。
2.getXmxHalf 为什么这么命名：app可以申请内存的最大值受ROM厂商自己打包修改的DVM 参数 xmx参数决定。xmx参数同样也是JVM可配置参数。所以，我命名用xmx来讲看起来更暴露原理一点。这里除以2,就是只要内存中有两个对象。那肯定会OOM。</p>
<blockquote>
<p>在android开发中，常见的android studio为了优化开发工具性能，studio64.vmoptions中把xmx参数配置大一点，就是这个原理，最大申请内存调整。因为，Android Studio是拿IDEA改的，IDEA是用Java开发的，IDEA同样也有这个配置文件。
这里有个搞笑的是idea可以开发很多东西，他的默认配置xmx参数居然比as的还小呢！或许我们可以猜测，AS被google团队优化的并不理想。</p>
</blockquote>
<h1></h1>
<p>下面:</p>
<h3>看完整的我放在Activity中的, 测试代码:</h3>
<p>下面的代码，我就没有拆分到多个方法中，我都放在一个方法中，测试时会不断的注释所有的保留其中一段代码，这样子我写道文章里易读性也高。因为代码挨着。</p>
<pre><code class="language-java">
public class TestAct extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        d(&quot;MAX_MEM:&quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;M&quot;);
        
        test();
        testBaseType();
    }


    private void test() {

        //1.会OOM 局部字段确实 释放是需要等到方法执行完毕才能释放
//            TestModel model = new TestModel();
//            TestModel model2 = new TestModel();
//            TestModel model3 = new TestModel();
//            TestModel model4 = new TestModel();

        // 2.这里GC无效 依旧OOM，因为本身 不可释放就不可释放，手动GC也不可被释放
//        TestModel model = new TestModel();
//        System.gc();
//        TestModel model2 = new TestModel();
//        System.gc();
//        TestModel model3 = new TestModel();
//        System.gc();
//        TestModel model4 = new TestModel();
//        System.gc();


        //3.不会OOM，而且看到了四个对象的finalize日志，由此可见：没有被引用的临时字段，不需要等到方法执行完毕 就可以释放，所以这样子写出来的代码内存释放的更快。
//            new TestModel();
//            new TestModel();
//            new TestModel();
//            new TestModel();


        //4.不会OOM   因为作用域太小了，作用域内的代码执行完毕，即可释放。
            {
                TestModel model = new TestModel();
            }
            System.gc();
            {
                TestModel model2 = new TestModel();
            }
            System.gc();
            {
                TestModel model3 = new TestModel();
            }
            System.gc();
            {
                TestModel model4 = new TestModel();
            }
            System.gc();



        //5.不会OOM   (即使我没有主动调用GC,但是内存达到JVM参数配置的 警戒线会自动触发系统的GC)
            {
                TestModel model = new TestModel();
            }
            {
                TestModel model2 = new TestModel();
            }
            {
                TestModel model3 = new TestModel();
            }
            {
                TestModel model4 = new TestModel();
            }


        // 6.这里不会OOM，理论上来说=null这行代码，会被JIT编译器删除掉，但是确实有效果了，这里很快看到了 finalize,但是我把 model 里面的内存消耗降到1M就看不到finalize日志了
//        TestModel model = new TestModel();
//        model=null;
//        TestModel model2 = new TestModel();
//        model2=null;
//        TestModel model3 = new TestModel();
//        model3=null;
//        TestModel model4 = new TestModel();
//        model4=null;


        // 7.这里不会OOM，依旧会触发 finalize  因为那块地址 指针已经被清空了，内存可以被释放， 同上原理一致
//        TestModel model = new TestModel();
//        model=  new TestModel();
//        model = new TestModel();
//        model =  new TestModel();


        //8.会OOM finalize 并没有什么卵用。
//        TestModel model = new TestModel();
//
//        try {
//            model.finalize();
//        } catch (Throwable throwable) {
//            throwable.printStackTrace();
//        }
//
//        TestModel model2 = new TestModel();
//
//        try {
//            model2.finalize();
//        } catch (Throwable throwable) {
//            throwable.printStackTrace();
//        }
//        TestModel model3 = new TestModel();
//        try {
//            model3.finalize();
//        } catch (Throwable throwable) {
//            throwable.printStackTrace();
//        }
//        TestModel model4 = new TestModel();
//        try {
//            model4.finalize();
//        } catch (Throwable throwable) {
//            throwable.printStackTrace();
//        }


    }

    ## 下面我们测试基础类型 的释放,测试基础类型是否遵循那一套逻辑 
    private void testBaseType() {

        //1.会OOM，可见非基础类型就不会  遵循 上面那一套逻辑 这里作用域虽然小了，但是 这里不讲堆内存那套逻辑
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//        }
//        {
//            byte[] mBytes1 = new byte[TestModel.getXmxHalf()];
//        }

        //3.会OOM 因为内存消耗过高 自动触发FullGC  这里写不写GC都没差
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//        }
//        System.gc();
//        {
//            byte[] mBytes1 = new byte[TestModel.getXmxHalf()];
//        }
//        System.gc();


        //3.会OOm  就算我把这个字段引用置空，也没用，照样OOM，但是普通对象是可以的，基础类型没用。请对比后面的那个测试代码。
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//            mBytes=null;
//        }
//        System.gc(); //写不写这句 没差 因为已经触发了 Full GC
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//            mBytes=null;
//        }
//        System.gc();


        //4. 这里不会OOM 比上面的代码多了&#x27;int a =0&#x27;这就是 说明局部字段在栈中 不在堆中 释放规则 比较特殊。可能你这个时候已经看的懵比了，别怕，这个为什么不会OOM的话，我下面总结里会细说。
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//            mBytes=null;
//            int a=0;
//        }
////        System.gc();//这句写不写都不会 OOM
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//            mBytes=null;
//            int a=0;
//        }
////        System.gc();


        //5. 这里不会OOm 请对比上面的 代码   这里会自动触发Full GC,而System.gc()只是 major GC。
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//            mBytes=null;
//            int a=0;
//        }
//        {
//            byte[] mBytes = new byte[TestModel.getXmxHalf()];
//            mBytes=null;
//            int a=0;
//        }
    }
    
    
}


</code></pre>
<h3>总结：</h3>
<h1></h1>
<p>1.上面有很多对比了，写和不写System.gc()的代码，这个没差的，因为JVM的GC释放策略里有个内存警戒线的概念，目前内存已经超出JVM的警戒线，会直接自动触发Full GC，内存警戒线。当然这个就是要看参数配置，不过除了警戒线之外的话，还有老年代新生代等等的一些触发Full GC。
Major GC或者Minjor GC只是俗称，在Hotspot JVM实现的Serial GC, Parallel GC, CMS, G1 GC中大致可以对应到某个Young GC和Old GC算法组合。</p>
<h1></h1>
<p>2.调用finalize并没有效果，其实在JVM规范中，finalize手动执行是有效的，只是JVM中也不推荐你调用，这里DVM，明显结果是：你用了也没有效果根本释放不了的。就像很多人说的，DVM并不遵循JVM规范。</p>
<h1></h1>
<p>3.System.gc并不是真的full GC了，他只是一个full gc的建议，看一些文档说JVM很大概率会采纳这个建议，但是我实际在android的DVM测试中，发现并没有触发FullGC。</p>
<h1></h1>
<p>4.基础类型中mBytes=null不释放，反而，后面用int a=0,就释放了，这里原因是因为这种基础类型存储在局部变量栈中，而就算你赋值空，他依旧在栈顶，就无法释放，重新插一个字段到栈的时候，原来可以被释放的栈顶元素才能被释放了。这一点DVM倒是保持了JVM规范。</p>
<h1></h1>
<p>5.上面测试对象释放的第三条，网上很多人会认为JIT编译器会把这几行代码从字节码中删除，因为JIT觉得这几行代码没有意义，应该可以删除掉，但是实际测试中，并没有被从字节码中删除，因为明显有看到四个字段被finalize的日志。实际上，JIT的删除规则，叫做<strong>死码删除(Dead Code Elimination)</strong>，永远都不会执行的代码，才会JIT被删除，那样子才是JIT认为的无用代码，而这里并不满足条件，JIT不会认为是无用代码。</p>
<h1></h1>
<p>6.内存什么时候入栈，什么时候入堆：</p>
<blockquote>
<ul>
<li>基本数据类型（int, short, long, byte, float, double, boolean, char），他们存储在栈内存中，函数调用它们的时候是”传值”；</li>
<li>复杂数据类型（数组, 对象, map, List, Set等），他们的实体存储在堆内存中，栈内存中只存储他们的对象的名称、通过堆内存的地址引用实体对象，函数调用它们的时候是”传引用地址”；</li>
</ul>
</blockquote>
<hr/>
<p>PS：如上代码，你们可以拷贝到自己项目里，在手机上进行测试，如有不同，请及时反馈。</p>
<p>延伸阅读：
<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E7%A2%BC%E5%88%AA%E9%99%A4">wiki上关于无用代码删除的介绍</a></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"Java局部字段释放规则探索","title":"Java局部字段释放规则探索.md","mdsource":"md/Java局部字段释放规则探索.md","date":" 2017/03/01 19:44:44","category":"几年后回看会觉得写的太烂"},"content":"title: Java局部字段释放规则探索\ndate: 2017/03/01 19:44:44\nupdated: 2017/04/27 10:49:16\ncategories:\n- 技术\n---\n可能很多人，对局部字段释放的规则一头雾水，只是单纯的知道 只要代码作用域结束了，那么作用域内的所有字段都可以被释放。\n在读《深入理解Java虚拟机》的时候，发现并非如此，其中的规则蛮复杂，堆内存和栈内存规则区别很大。\n\n### 关于堆内存和栈内存：\n\u003e 节选自《深入理解Java虚拟机》\n经常有人把Java内存区分为堆内存( Heap )和栈内存( Stack),这种分法比较粗 \n糙 ,Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面会专门讲述,而所指的“栈”就是现在讲的虚拟机栈,或者说是虚拟机栈中局部变量表部分。\n\n所以我们写代码测试一下，试着找寻释放规则。\n\n``` java\npublic class TestModel {\n\n    //这个值希望设置为Runtime.getRuntime().maxMemory()/2 的值,这样子内存中一旦有一个没有被释放则直接OOM\n    final byte[] mBytes = new byte[getXmxHalf()];//\n\n    @Override\n    protected void finalize() throws Throwable {\n        Log.d(\"TestModel\",\"finalize()\"); //当内存被释放时 我可以从日志中看到\n        super.finalize();\n    }\n\n    //内存的最大值取决于 JVM的xmx参数配置 所以这里取一半，只要内存中有两个  即可发生OOM\n    public static int getXmxHalf()\n    {\n        return (int)(Runtime.getRuntime().maxMemory()/2);\n    }\n}\n\n\n```\n###上面这些代码中有两点需要说明：\n1.finalize是什么： 这个是GC管理器释放一个对象时调用的方法。\n2.getXmxHalf 为什么这么命名：app可以申请内存的最大值受ROM厂商自己打包修改的DVM 参数 xmx参数决定。xmx参数同样也是JVM可配置参数。所以，我命名用xmx来讲看起来更暴露原理一点。这里除以2,就是只要内存中有两个对象。那肯定会OOM。\n\n\u003e 在android开发中，常见的android studio为了优化开发工具性能，studio64.vmoptions中把xmx参数配置大一点，就是这个原理，最大申请内存调整。因为，Android Studio是拿IDEA改的，IDEA是用Java开发的，IDEA同样也有这个配置文件。\n这里有个搞笑的是idea可以开发很多东西，他的默认配置xmx参数居然比as的还小呢！或许我们可以猜测，AS被google团队优化的并不理想。\n\n# \n下面:\n### 看完整的我放在Activity中的, 测试代码:\n下面的代码，我就没有拆分到多个方法中，我都放在一个方法中，测试时会不断的注释所有的保留其中一段代码，这样子我写道文章里易读性也高。因为代码挨着。\n\n```  java\n\npublic class TestAct extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        d(\"MAX_MEM:\" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + \"M\");\n        \n        test();\n        testBaseType();\n    }\n\n\n    private void test() {\n\n        //1.会OOM 局部字段确实 释放是需要等到方法执行完毕才能释放\n//            TestModel model = new TestModel();\n//            TestModel model2 = new TestModel();\n//            TestModel model3 = new TestModel();\n//            TestModel model4 = new TestModel();\n\n        // 2.这里GC无效 依旧OOM，因为本身 不可释放就不可释放，手动GC也不可被释放\n//        TestModel model = new TestModel();\n//        System.gc();\n//        TestModel model2 = new TestModel();\n//        System.gc();\n//        TestModel model3 = new TestModel();\n//        System.gc();\n//        TestModel model4 = new TestModel();\n//        System.gc();\n\n\n        //3.不会OOM，而且看到了四个对象的finalize日志，由此可见：没有被引用的临时字段，不需要等到方法执行完毕 就可以释放，所以这样子写出来的代码内存释放的更快。\n//            new TestModel();\n//            new TestModel();\n//            new TestModel();\n//            new TestModel();\n\n\n        //4.不会OOM   因为作用域太小了，作用域内的代码执行完毕，即可释放。\n            {\n                TestModel model = new TestModel();\n            }\n            System.gc();\n            {\n                TestModel model2 = new TestModel();\n            }\n            System.gc();\n            {\n                TestModel model3 = new TestModel();\n            }\n            System.gc();\n            {\n                TestModel model4 = new TestModel();\n            }\n            System.gc();\n\n\n\n        //5.不会OOM   (即使我没有主动调用GC,但是内存达到JVM参数配置的 警戒线会自动触发系统的GC)\n            {\n                TestModel model = new TestModel();\n            }\n            {\n                TestModel model2 = new TestModel();\n            }\n            {\n                TestModel model3 = new TestModel();\n            }\n            {\n                TestModel model4 = new TestModel();\n            }\n\n\n        // 6.这里不会OOM，理论上来说=null这行代码，会被JIT编译器删除掉，但是确实有效果了，这里很快看到了 finalize,但是我把 model 里面的内存消耗降到1M就看不到finalize日志了\n//        TestModel model = new TestModel();\n//        model=null;\n//        TestModel model2 = new TestModel();\n//        model2=null;\n//        TestModel model3 = new TestModel();\n//        model3=null;\n//        TestModel model4 = new TestModel();\n//        model4=null;\n\n\n        // 7.这里不会OOM，依旧会触发 finalize  因为那块地址 指针已经被清空了，内存可以被释放， 同上原理一致\n//        TestModel model = new TestModel();\n//        model=  new TestModel();\n//        model = new TestModel();\n//        model =  new TestModel();\n\n\n        //8.会OOM finalize 并没有什么卵用。\n//        TestModel model = new TestModel();\n//\n//        try {\n//            model.finalize();\n//        } catch (Throwable throwable) {\n//            throwable.printStackTrace();\n//        }\n//\n//        TestModel model2 = new TestModel();\n//\n//        try {\n//            model2.finalize();\n//        } catch (Throwable throwable) {\n//            throwable.printStackTrace();\n//        }\n//        TestModel model3 = new TestModel();\n//        try {\n//            model3.finalize();\n//        } catch (Throwable throwable) {\n//            throwable.printStackTrace();\n//        }\n//        TestModel model4 = new TestModel();\n//        try {\n//            model4.finalize();\n//        } catch (Throwable throwable) {\n//            throwable.printStackTrace();\n//        }\n\n\n    }\n\n    ## 下面我们测试基础类型 的释放,测试基础类型是否遵循那一套逻辑 \n    private void testBaseType() {\n\n        //1.会OOM，可见非基础类型就不会  遵循 上面那一套逻辑 这里作用域虽然小了，但是 这里不讲堆内存那套逻辑\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//        }\n//        {\n//            byte[] mBytes1 = new byte[TestModel.getXmxHalf()];\n//        }\n\n        //3.会OOM 因为内存消耗过高 自动触发FullGC  这里写不写GC都没差\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//        }\n//        System.gc();\n//        {\n//            byte[] mBytes1 = new byte[TestModel.getXmxHalf()];\n//        }\n//        System.gc();\n\n\n        //3.会OOm  就算我把这个字段引用置空，也没用，照样OOM，但是普通对象是可以的，基础类型没用。请对比后面的那个测试代码。\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//            mBytes=null;\n//        }\n//        System.gc(); //写不写这句 没差 因为已经触发了 Full GC\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//            mBytes=null;\n//        }\n//        System.gc();\n\n\n        //4. 这里不会OOM 比上面的代码多了'int a =0'这就是 说明局部字段在栈中 不在堆中 释放规则 比较特殊。可能你这个时候已经看的懵比了，别怕，这个为什么不会OOM的话，我下面总结里会细说。\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//            mBytes=null;\n//            int a=0;\n//        }\n////        System.gc();//这句写不写都不会 OOM\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//            mBytes=null;\n//            int a=0;\n//        }\n////        System.gc();\n\n\n        //5. 这里不会OOm 请对比上面的 代码   这里会自动触发Full GC,而System.gc()只是 major GC。\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//            mBytes=null;\n//            int a=0;\n//        }\n//        {\n//            byte[] mBytes = new byte[TestModel.getXmxHalf()];\n//            mBytes=null;\n//            int a=0;\n//        }\n    }\n    \n    \n}\n\n\n```\n### 总结：\n# \n1.上面有很多对比了，写和不写System.gc()的代码，这个没差的，因为JVM的GC释放策略里有个内存警戒线的概念，目前内存已经超出JVM的警戒线，会直接自动触发Full GC，内存警戒线。当然这个就是要看参数配置，不过除了警戒线之外的话，还有老年代新生代等等的一些触发Full GC。\nMajor GC或者Minjor GC只是俗称，在Hotspot JVM实现的Serial GC, Parallel GC, CMS, G1 GC中大致可以对应到某个Young GC和Old GC算法组合。\n# \n2.调用finalize并没有效果，其实在JVM规范中，finalize手动执行是有效的，只是JVM中也不推荐你调用，这里DVM，明显结果是：你用了也没有效果根本释放不了的。就像很多人说的，DVM并不遵循JVM规范。\n# \n3.System.gc并不是真的full GC了，他只是一个full gc的建议，看一些文档说JVM很大概率会采纳这个建议，但是我实际在android的DVM测试中，发现并没有触发FullGC。\n# \n4.基础类型中mBytes=null不释放，反而，后面用int a=0,就释放了，这里原因是因为这种基础类型存储在局部变量栈中，而就算你赋值空，他依旧在栈顶，就无法释放，重新插一个字段到栈的时候，原来可以被释放的栈顶元素才能被释放了。这一点DVM倒是保持了JVM规范。\n# \n5.上面测试对象释放的第三条，网上很多人会认为JIT编译器会把这几行代码从字节码中删除，因为JIT觉得这几行代码没有意义，应该可以删除掉，但是实际测试中，并没有被从字节码中删除，因为明显有看到四个字段被finalize的日志。实际上，JIT的删除规则，叫做**死码删除(Dead Code Elimination)**，永远都不会执行的代码，才会JIT被删除，那样子才是JIT认为的无用代码，而这里并不满足条件，JIT不会认为是无用代码。\n# \n6.内存什么时候入栈，什么时候入堆：\n\u003e + 基本数据类型（int, short, long, byte, float, double, boolean, char），他们存储在栈内存中，函数调用它们的时候是”传值”；\n\u003e + 复杂数据类型（数组, 对象, map, List, Set等），他们的实体存储在堆内存中，栈内存中只存储他们的对象的名称、通过堆内存的地址引用实体对象，函数调用它们的时候是”传引用地址”；\n\n--------------------------------\nPS：如上代码，你们可以拷贝到自己项目里，在手机上进行测试，如有不同，请及时反馈。\n\n延伸阅读：\n[wiki上关于无用代码删除的介绍](https://zh.wikipedia.org/wiki/%E6%AD%BB%E7%A2%BC%E5%88%AA%E9%99%A4)\n\n\n","lang":"cn"},"__N_SSG":true},"page":"/[lang]/blog/[slug]","query":{"lang":"cn","slug":"Java局部字段释放规则探索"},"buildId":"GHV3Hdifg6RQFG6pfrsvS","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>