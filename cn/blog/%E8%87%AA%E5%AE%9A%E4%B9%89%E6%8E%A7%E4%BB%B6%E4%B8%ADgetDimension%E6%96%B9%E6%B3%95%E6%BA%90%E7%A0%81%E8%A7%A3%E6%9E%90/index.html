<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1, width=device-width"/><meta name="emotion-insertion-point" content=""/><title>自定义控件中getDimension方法源码解析.md<!-- --> - BruceWind&#x27;s Blog</title><meta name="description" content="自定义控件中getDimension方法源码解析.md - 几年后回看会觉得写的太烂"/><meta property="og:title" content="自定义控件中getDimension方法源码解析.md"/><meta property="og:type" content="article"/><meta property="article:published_time" content=" 2015/09/16 23:01:22"/><meta name="next-head-count" content="8"/><meta charSet="utf-8"/><meta name="keywords" content="NDK,JNI,Android Dev,android,androidyuan,性能优化,Linux,developer"/><meta name="description" content="BruceWind&#x27;s personal blog - Android development, Linux, and more."/><meta name="robots" content="index,follow"/><meta name="google" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="author" content="bruce"/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#000000"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LGE1LT9YJG"></script><script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', 'G-LGE1LT9YJG');
              </script><style data-emotion="mui-style-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><style data-emotion="mui-style 17ro72p 1cp6o32 79elbk 1qo0fs4 1uf4bbi 1m9pwf3 19gndve 1ju1kxc k1u9gz 6xugel vubbuv gtvj52 1x1vlev vax71z">.mui-style-17ro72p{width:100%;min-height:100vh;background-color:#fff;padding:16px;}.mui-style-1cp6o32{background-color:#fff;color:rgba(0, 0, 0, 0.87);-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12);padding:24px;}.mui-style-79elbk{position:relative;}.mui-style-1qo0fs4{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;width:58px;height:38px;overflow:hidden;padding:12px;box-sizing:border-box;position:relative;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;z-index:0;vertical-align:middle;width:62px;height:34px;padding:7px;margin:8px;}@media print{.mui-style-1qo0fs4{-webkit-print-color-adjust:exact;color-adjust:exact;}}.mui-style-1qo0fs4 .MuiSwitch-switchBase{margin:1px;padding:0;-webkit-transform:translateX(6px);-moz-transform:translateX(6px);-ms-transform:translateX(6px);transform:translateX(6px);}.mui-style-1qo0fs4 .MuiSwitch-switchBase.Mui-checked{color:#fff;-webkit-transform:translateX(22px);-moz-transform:translateX(22px);-ms-transform:translateX(22px);transform:translateX(22px);}.mui-style-1qo0fs4 .MuiSwitch-switchBase.Mui-checked .MuiSwitch-thumb:before{background-image:url('data:image/svg+xml;utf8,<?xml version="1.0" ?><svg height="20" width="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g><path d="M0 0h24v24H0z" fill="none"/><path fill="white" d="M12 19a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm-5.5 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm11 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zM13 2v2h6v2h-1.968a18.222 18.222 0 0 1-3.621 6.302 14.685 14.685 0 0 0 5.327 3.042l-.536 1.93A16.685 16.685 0 0 1 12 13.726a16.696 16.696 0 0 1-6.202 3.547l-.536-1.929a14.7 14.7 0 0 0 5.327-3.042 18.077 18.077 0 0 1-2.822-4.3h2.24A16.031 16.031 0 0 0 12 10.876a16.168 16.168 0 0 0 2.91-4.876L5 6V4h6V2h2z"/></g></svg>');}.mui-style-1qo0fs4 .MuiSwitch-switchBase.Mui-checked+.MuiSwitch-track{opacity:1;background-color:#aab4be;}.mui-style-1qo0fs4 .MuiSwitch-thumb{background-color:#001e3c;width:32px;height:32px;}.mui-style-1qo0fs4 .MuiSwitch-thumb:before{content:'';position:absolute;width:100%;height:100%;left:0;top:0;background-repeat:no-repeat;-webkit-background-position:center;background-position:center;background-image:url('data:image/svg+xml;utf8,<?xml version="1.0" ?><svg height="20" width="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none" /><path fill="white" d="M14 10h2v.757a4.5 4.5 0 0 1 7 3.743V20h-2v-5.5c0-1.43-1.175-2.5-2.5-2.5S16 13.07 16 14.5V20h-2V10zm-2-6v2H4v5h8v2H4v5h8v2H2V4h10z"/></svg>');}.mui-style-1qo0fs4 .MuiSwitch-track{opacity:1;background-color:#aab4be;border-radius:10px;}.mui-style-1uf4bbi{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;padding:9px;border-radius:50%;position:absolute;top:0;left:0;z-index:1;color:#fff;-webkit-transition:left 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,-webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:left 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,transform 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;}.mui-style-1uf4bbi::-moz-focus-inner{border-style:none;}.mui-style-1uf4bbi.Mui-disabled{pointer-events:none;cursor:default;}@media print{.mui-style-1uf4bbi{-webkit-print-color-adjust:exact;color-adjust:exact;}}.mui-style-1uf4bbi.Mui-checked{-webkit-transform:translateX(20px);-moz-transform:translateX(20px);-ms-transform:translateX(20px);transform:translateX(20px);}.mui-style-1uf4bbi.Mui-disabled{color:#f5f5f5;}.mui-style-1uf4bbi.Mui-checked+.MuiSwitch-track{opacity:0.5;}.mui-style-1uf4bbi.Mui-disabled+.MuiSwitch-track{opacity:0.12;}.mui-style-1uf4bbi .MuiSwitch-input{left:-100%;width:300%;}.mui-style-1uf4bbi:hover{background-color:rgba(0, 0, 0, 0.04);}@media (hover: none){.mui-style-1uf4bbi:hover{background-color:transparent;}}.mui-style-1uf4bbi.Mui-checked{color:#1976d2;}.mui-style-1uf4bbi.Mui-checked:hover{background-color:rgba(25, 118, 210, 0.04);}@media (hover: none){.mui-style-1uf4bbi.Mui-checked:hover{background-color:transparent;}}.mui-style-1uf4bbi.Mui-checked.Mui-disabled{color:rgb(167, 202, 237);}.mui-style-1uf4bbi.Mui-checked+.MuiSwitch-track{background-color:#1976d2;}.mui-style-1m9pwf3{cursor:inherit;position:absolute;opacity:0;width:100%;height:100%;top:0;left:0;margin:0;padding:0;z-index:1;}.mui-style-19gndve{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);background-color:currentColor;width:20px;height:20px;border-radius:50%;}.mui-style-1ju1kxc{height:100%;width:100%;border-radius:7px;z-index:-1;-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;background-color:#000;opacity:0.38;}.mui-style-k1u9gz{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:500;font-size:0.875rem;line-height:1.75;letter-spacing:0.02857em;text-transform:uppercase;min-width:64px;padding:6px 8px;border-radius:4px;-webkit-transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:#1976d2;margin-bottom:16px;}.mui-style-k1u9gz::-moz-focus-inner{border-style:none;}.mui-style-k1u9gz.Mui-disabled{pointer-events:none;cursor:default;}@media print{.mui-style-k1u9gz{-webkit-print-color-adjust:exact;color-adjust:exact;}}.mui-style-k1u9gz:hover{-webkit-text-decoration:none;text-decoration:none;background-color:rgba(25, 118, 210, 0.04);}@media (hover: none){.mui-style-k1u9gz:hover{background-color:transparent;}}.mui-style-k1u9gz.Mui-disabled{color:rgba(0, 0, 0, 0.26);}.mui-style-6xugel{display:inherit;margin-right:8px;margin-left:-4px;}.mui-style-6xugel>*:nth-of-type(1){font-size:20px;}.mui-style-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}.mui-style-gtvj52{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:2.125rem;line-height:1.235;letter-spacing:0.00735em;margin-bottom:0.35em;}.mui-style-1x1vlev{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;margin-bottom:0.35em;color:rgba(0, 0, 0, 0.6);}.mui-style-vax71z{margin:0;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;border-width:0;border-style:solid;border-color:rgba(0, 0, 0, 0.12);border-bottom-width:thin;margin-top:16px;margin-bottom:16px;}</style><link rel="preload" href="/_next/static/css/345ff263c1768dbb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/345ff263c1768dbb.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-6ef43a8d4a395f49.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-5b2299ded1a46c83.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4f0aaa3a6ba99024.js" defer=""></script><script src="/_next/static/chunks/34-75ae01f5fa578a9a.js" defer=""></script><script src="/_next/static/chunks/995-a5f98cc3a4d14286.js" defer=""></script><script src="/_next/static/chunks/771-702e6dcd51d5534b.js" defer=""></script><script src="/_next/static/chunks/pages/%5Blang%5D/blog/%5Bslug%5D-f7777f3ea9ebdd54.js" defer=""></script><script src="/_next/static/HT0wMZc9WfQm5UQ_5R-LL/_buildManifest.js" defer=""></script><script src="/_next/static/HT0wMZc9WfQm5UQ_5R-LL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="MuiBox-root mui-style-17ro72p"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation3 mui-style-1cp6o32"><div class="MuiBox-root mui-style-79elbk"><div style="position:absolute;top:22px;right:15px;height:100px;z-index:1300"><span class="MuiSwitch-root MuiSwitch-sizeMedium mui-style-1qo0fs4"><span class="MuiButtonBase-root MuiSwitch-switchBase MuiSwitch-colorPrimary Mui-checked PrivateSwitchBase-root MuiSwitch-switchBase MuiSwitch-colorPrimary Mui-checked Mui-checked mui-style-1uf4bbi"><input class="PrivateSwitchBase-input MuiSwitch-input mui-style-1m9pwf3" type="checkbox" checked=""/><span class="MuiSwitch-thumb mui-style-19gndve"></span></span><span class="MuiSwitch-track mui-style-1ju1kxc"></span></span></div><a class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorPrimary MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorPrimary mui-style-k1u9gz" tabindex="0" href="/cn/"><span class="MuiButton-icon MuiButton-startIcon MuiButton-iconSizeMedium mui-style-6xugel"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-style-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ArrowBackIcon"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"></path></svg></span>返回列表</a><h1 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom mui-style-gtvj52">自定义控件中getDimension方法源码解析.md</h1><p class="MuiTypography-root MuiTypography-body2 MuiTypography-gutterBottom mui-style-1x1vlev">几年后回看会觉得写的太烂<!-- --> | <!-- --> 2015/09/16 23:01:22</p><hr class="MuiDivider-root MuiDivider-fullWidth mui-style-vax71z"/><div class="markdown-body"><p>title: 自定义控件中getDimension方法源码解析
date: 2015/09/16 23:01:22
updated: 2016/02/25 00:29:16
categories:</p>
<ul>
<li>技术</li>
</ul>
<hr/>
<p>getDimension()
getDimensionPixelOffset()
两个方法的区别在哪？</p>
<h1></h1>
<p>先贴出这个方法的源码：（方法的理解，我写进注释里了）</p>
<pre><code class="language-java">
//getDimension
	 public float getDimension(int index, float defValue) {
	 
		......//省略部分判断的代码
			
        index *= AssetManager.STYLE_NUM_ENTRIES;
        final int[] data = mData;
        final int type = data[index+AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
	        //空的时候返回默认值
            return defValue;
        } else if (type == TypedValue.TYPE_DIMENSION) {
	        //类型正确的时候往下走
            return TypedValue.complexToDimension(
                data[index+AssetManager.STYLE_DATA], mMetrics);
        } else if (type == TypedValue.TYPE_ATTRIBUTE) {
	        //类型不正确的时候抛出异常
            throw new RuntimeException(&quot;Failed to resolve attribute at index &quot; + index);
        }
		......

    }

//getDimensionPixelOffset
public int getDimensionPixelOffset(int index, int defValue) {

		......
        index *= AssetManager.STYLE_NUM_ENTRIES;
        final int[] data = mData;
        final int type = data[index+AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            return defValue;
        } else if (type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelOffset(
                data[index+AssetManager.STYLE_DATA], mMetrics);
        } else if (type == TypedValue.TYPE_ATTRIBUTE) {
            throw new RuntimeException(&quot;Failed to resolve attribute at index &quot; + index);
        }
		......

    }

</code></pre>
<p>这两个方法的源代码呢，似乎都差不多的东西。</p>
<pre><code>区别就在于：一个是执行了TypedValue.complexToDimension 一个是执行了TypedValue.complexToDimensionPixelOffse。
</code></pre>
<p>等会再看complexToDimension方法。我们先来看下mData这个字段。</p>
<h1></h1>
<p>由于再getDimension之前，我们调用了context.obtainStyleAttr()，mData被追踪到了这里。
那么我们看下这个方法的代码:</p>
<pre><code class="language-java">
 public TypedArray obtainStyledAttributes(AttributeSet set,
                int[] attrs, int defStyleAttr, int defStyleRes) {
            final int len = attrs.length;
            final TypedArray array = TypedArray.obtain(Resources.this, len);

            // XXX note that for now we only work with compiled XML files.
            // To support generic XML files we will need to manually parse
            // out the attributes from the XML file (applying type information
            // contained in the resources and such).
            final XmlBlock.Parser parser = (XmlBlock.Parser)set;
            AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes,
                    parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);

            array.mTheme = this;
            array.mXml = parser;

            if (false) {
                int[] data = array.mData;
                
                System.out.println(&quot;Attributes:&quot;);
                String s = &quot;  Attrs:&quot;;
                int i;
                for (i=0; i&lt;set.getAttributeCount(); i++) {
                    s = s + &quot; &quot; + set.getAttributeName(i);
                    int id = set.getAttributeNameResource(i);
                    if (id != 0) {
                        s = s + &quot;(0x&quot; + Integer.toHexString(id) + &quot;)&quot;;
                    }
                    s = s + &quot;=&quot; + set.getAttributeValue(i);
                }
                System.out.println(s);
                s = &quot;  Found:&quot;;
                TypedValue value = new TypedValue();
                for (i=0; i&lt;attrs.length; i++) {
                    int d = i*AssetManager.STYLE_NUM_ENTRIES;
                    value.type = data[d+AssetManager.STYLE_TYPE];
                    value.data = data[d+AssetManager.STYLE_DATA];
                    value.assetCookie = data[d+AssetManager.STYLE_ASSET_COOKIE];
                    value.resourceId = data[d+AssetManager.STYLE_RESOURCE_ID];
                    s = s + &quot; 0x&quot; + Integer.toHexString(attrs[i])
                        + &quot;=&quot; + value;
                }
                System.out.println(s);
            }

            return array;
        }

</code></pre>
<p>我们直接就看 TypedValue.complexToDimension(......);
这个static方法吧?</p>
<h1></h1>
<p>上代码 :</p>
<pre><code class="language-java">
//TypeArray 内 getDimension方法调用了这里
public static float complexToDimension(int data, DisplayMetrics metrics)
    {
        return applyDimension(
            (data&gt;&gt;COMPLEX_UNIT_SHIFT)&amp;COMPLEX_UNIT_MASK,
            complexToFloat(data),
            metrics);
    }


//TypeArray 内 getDimensionPixelOffset方法调用了这里
 public static int complexToDimensionPixelOffset(int data,
            DisplayMetrics metrics)
    {
        return (int)applyDimension(
                (data&gt;&gt;COMPLEX_UNIT_SHIFT)&amp;COMPLEX_UNIT_MASK,
                complexToFloat(data),
                metrics);
    }

</code></pre>
<p>好了大概逻辑就是这样子 :
getDimension                  -&gt; complexToDimension
getDimensionPixelOffset -&gt; complexToDimensionPixelOffset</p>
<p>其中， (data&gt;&gt;COMPLEX_UNIT_SHIFT) &amp; COMPLEX_UNIT_MASK的意思是将该int值与上0xf，以获取其最低4位，这4位是<strong>单位</strong>。而complexToFloat则是使用该int值的最高24位当作数值，4-7位作为radix，进行计算，转成float。</p>
<p>而这个complexToDimension与complexToDimensionPixelOffset方法内的代码一样的,只是一个被强制转类型为int了,一个没有被强制转。</p>
<p>那么，getDimension与getDimensionPixelOffset得到的值应该是几乎相等的，误差就在于类型强转。<br/>
所以可得到官网提到的这个“原始像素带有偏移量”，这个词或许他的意思就是比较精确地像素和不太精确地，但是这里误差是小于1像素的，那么这个0.1的精确好像作用不大啊！</p>
<pre><code>这里我也无法理解为何这个不到1像素的误差为何还要区分出来两个方法，可能有些地方为了这些小的不到一个像素的多余的位置在对于一个布局是很重要的，如果一个横向分辨率是720的手机，父控件有横向有两个子控件，也是用这种dp属性的计算，最后计算得出的一个是359.6一个是360.4，这里子控件显示的时候肯定是知道自己的宽度的整数即可，但是父控件或许是需要知道他们的带小数点的值来求得总和的实际宽度。
</code></pre>
<p>然后他指向了applyDimension(....)方法,我们看下applyDimension()方法的代码:</p>
<pre><code class="language-java">
public static float applyDimension(int unit, float value,
                                       DisplayMetrics metrics)
    {
        switch (unit) {
        case COMPLEX_UNIT_PX:
            return value;
        case COMPLEX_UNIT_DIP:
            return value * metrics.density;
        case COMPLEX_UNIT_SP:
            return value * metrics.scaledDensity;
        case COMPLEX_UNIT_PT:
            return value * metrics.xdpi * (1.0f/72);
        case COMPLEX_UNIT_IN:
            return value * metrics.xdpi;
        case COMPLEX_UNIT_MM:
            return value * metrics.xdpi * (1.0f/25.4f);
        }
        return 0;
    }

</code></pre>
<p>applyDimension的第一个参数代表他是什么单位，然后根据不同的单位返回相同的值。</p>
<p>在applyDimension中根据单位的不同，将float乘上不同的系数。如dip/dp需乘上屏幕系数，sp需乘上字号的缩放系数，pt、in、mm等也是根据相应的算法进行换算。</p>
<pre><code>return value * metrics.density; 这个代码跟我们平时手动写dp2px方法的代码几乎是一样的，我们平时可能是为了误差的问题在后面加上0.5*density。
</code></pre>
<p>其实这里有有一点要提的是：dp px  mm 等，在系统中都是以 &quot;数值+单位&quot; 在系统中存储的。</p>
<p>比如：</p>
<pre><code class="language-xml">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;resources&gt;  
    &lt;dimen name=&quot;zl_def_indicator_radius&quot;&gt;4dp&lt;/dimen&gt;  
    &lt;dimen name=&quot;zl_def_font_size&quot;&gt;16sp&lt;/dimen&gt;  
&lt;/resources&gt;  

</code></pre>
<p>这种存起来的时候都是以 &quot;数值+单位&quot; 存储的.</p>
<p>Android的Resoureces类的getDimension方法，对于不同的dimension，在使用getValue获取到对应的int值之后，会通过TypedValue的complextoDimension方法将其转换为float。</p>
<h1></h1>
<p>本文涉及到的github的android源码，地址如下：</p>
<pre><code>https://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/Context.java
https://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/Resources.java
https://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/AssetManager.java
https://github.com/android/platform_frameworks_base/blob/master/core/java/android/util/TypedValue.java
https://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/TypedArray.java
https://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/Resources.java
</code></pre></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B8%ADgetDimension%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90","title":"自定义控件中getDimension方法源码解析.md","mdsource":"md/自定义控件中getDimension方法源码解析.md","date":" 2015/09/16 23:01:22","category":"几年后回看会觉得写的太烂"},"content":"title: 自定义控件中getDimension方法源码解析\ndate: 2015/09/16 23:01:22\nupdated: 2016/02/25 00:29:16\ncategories:\n- 技术\n---\n\ngetDimension() \ngetDimensionPixelOffset() \n两个方法的区别在哪？ \n\n# \n\n先贴出这个方法的源码：（方法的理解，我写进注释里了）\n\n``` java\n\n//getDimension\n\t public float getDimension(int index, float defValue) {\n\t \n\t\t......//省略部分判断的代码\n\t\t\t\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        final int type = data[index+AssetManager.STYLE_TYPE];\n        if (type == TypedValue.TYPE_NULL) {\n\t        //空的时候返回默认值\n            return defValue;\n        } else if (type == TypedValue.TYPE_DIMENSION) {\n\t        //类型正确的时候往下走\n            return TypedValue.complexToDimension(\n                data[index+AssetManager.STYLE_DATA], mMetrics);\n        } else if (type == TypedValue.TYPE_ATTRIBUTE) {\n\t        //类型不正确的时候抛出异常\n            throw new RuntimeException(\"Failed to resolve attribute at index \" + index);\n        }\n\t\t......\n\n    }\n\n//getDimensionPixelOffset\npublic int getDimensionPixelOffset(int index, int defValue) {\n\n\t\t......\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        final int type = data[index+AssetManager.STYLE_TYPE];\n        if (type == TypedValue.TYPE_NULL) {\n            return defValue;\n        } else if (type == TypedValue.TYPE_DIMENSION) {\n            return TypedValue.complexToDimensionPixelOffset(\n                data[index+AssetManager.STYLE_DATA], mMetrics);\n        } else if (type == TypedValue.TYPE_ATTRIBUTE) {\n            throw new RuntimeException(\"Failed to resolve attribute at index \" + index);\n        }\n\t\t......\n\n    }\n\n```\n这两个方法的源代码呢，似乎都差不多的东西。\n\t\n\t区别就在于：一个是执行了TypedValue.complexToDimension 一个是执行了TypedValue.complexToDimensionPixelOffse。\n\n等会再看complexToDimension方法。我们先来看下mData这个字段。\n# \n由于再getDimension之前，我们调用了context.obtainStyleAttr()，mData被追踪到了这里。\n那么我们看下这个方法的代码:\n``` java\n\n public TypedArray obtainStyledAttributes(AttributeSet set,\n                int[] attrs, int defStyleAttr, int defStyleRes) {\n            final int len = attrs.length;\n            final TypedArray array = TypedArray.obtain(Resources.this, len);\n\n            // XXX note that for now we only work with compiled XML files.\n            // To support generic XML files we will need to manually parse\n            // out the attributes from the XML file (applying type information\n            // contained in the resources and such).\n            final XmlBlock.Parser parser = (XmlBlock.Parser)set;\n            AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes,\n                    parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);\n\n            array.mTheme = this;\n            array.mXml = parser;\n\n            if (false) {\n                int[] data = array.mData;\n                \n                System.out.println(\"Attributes:\");\n                String s = \"  Attrs:\";\n                int i;\n                for (i=0; i\u003cset.getAttributeCount(); i++) {\n                    s = s + \" \" + set.getAttributeName(i);\n                    int id = set.getAttributeNameResource(i);\n                    if (id != 0) {\n                        s = s + \"(0x\" + Integer.toHexString(id) + \")\";\n                    }\n                    s = s + \"=\" + set.getAttributeValue(i);\n                }\n                System.out.println(s);\n                s = \"  Found:\";\n                TypedValue value = new TypedValue();\n                for (i=0; i\u003cattrs.length; i++) {\n                    int d = i*AssetManager.STYLE_NUM_ENTRIES;\n                    value.type = data[d+AssetManager.STYLE_TYPE];\n                    value.data = data[d+AssetManager.STYLE_DATA];\n                    value.assetCookie = data[d+AssetManager.STYLE_ASSET_COOKIE];\n                    value.resourceId = data[d+AssetManager.STYLE_RESOURCE_ID];\n                    s = s + \" 0x\" + Integer.toHexString(attrs[i])\n                        + \"=\" + value;\n                }\n                System.out.println(s);\n            }\n\n            return array;\n        }\n\n```\n\n\n\n我们直接就看 TypedValue.complexToDimension(......);\n        这个static方法吧?\n\n# \n上代码 :\n\n``` java\n\n//TypeArray 内 getDimension方法调用了这里\npublic static float complexToDimension(int data, DisplayMetrics metrics)\n    {\n        return applyDimension(\n            (data\u003e\u003eCOMPLEX_UNIT_SHIFT)\u0026COMPLEX_UNIT_MASK,\n            complexToFloat(data),\n            metrics);\n    }\n\n\n//TypeArray 内 getDimensionPixelOffset方法调用了这里\n public static int complexToDimensionPixelOffset(int data,\n            DisplayMetrics metrics)\n    {\n        return (int)applyDimension(\n                (data\u003e\u003eCOMPLEX_UNIT_SHIFT)\u0026COMPLEX_UNIT_MASK,\n                complexToFloat(data),\n                metrics);\n    }\n\n```\n\n好了大概逻辑就是这样子 :\n\t\tgetDimension                  -\u003e complexToDimension\n\t\tgetDimensionPixelOffset -\u003e complexToDimensionPixelOffset\n\n其中， (data\u003e\u003eCOMPLEX_UNIT_SHIFT) \u0026 COMPLEX_UNIT_MASK的意思是将该int值与上0xf，以获取其最低4位，这4位是**单位**。而complexToFloat则是使用该int值的最高24位当作数值，4-7位作为radix，进行计算，转成float。\n\n而这个complexToDimension与complexToDimensionPixelOffset方法内的代码一样的,只是一个被强制转类型为int了,一个没有被强制转。\n\n那么，getDimension与getDimensionPixelOffset得到的值应该是几乎相等的，误差就在于类型强转。  \n所以可得到官网提到的这个“原始像素带有偏移量”，这个词或许他的意思就是比较精确地像素和不太精确地，但是这里误差是小于1像素的，那么这个0.1的精确好像作用不大啊！\n\t\n\t这里我也无法理解为何这个不到1像素的误差为何还要区分出来两个方法，可能有些地方为了这些小的不到一个像素的多余的位置在对于一个布局是很重要的，如果一个横向分辨率是720的手机，父控件有横向有两个子控件，也是用这种dp属性的计算，最后计算得出的一个是359.6一个是360.4，这里子控件显示的时候肯定是知道自己的宽度的整数即可，但是父控件或许是需要知道他们的带小数点的值来求得总和的实际宽度。\n\n\n\n然后他指向了applyDimension(....)方法,我们看下applyDimension()方法的代码:\n\n``` java\n\npublic static float applyDimension(int unit, float value,\n                                       DisplayMetrics metrics)\n    {\n        switch (unit) {\n        case COMPLEX_UNIT_PX:\n            return value;\n        case COMPLEX_UNIT_DIP:\n            return value * metrics.density;\n        case COMPLEX_UNIT_SP:\n            return value * metrics.scaledDensity;\n        case COMPLEX_UNIT_PT:\n            return value * metrics.xdpi * (1.0f/72);\n        case COMPLEX_UNIT_IN:\n            return value * metrics.xdpi;\n        case COMPLEX_UNIT_MM:\n            return value * metrics.xdpi * (1.0f/25.4f);\n        }\n        return 0;\n    }\n\n```\napplyDimension的第一个参数代表他是什么单位，然后根据不同的单位返回相同的值。\n\n\n在applyDimension中根据单位的不同，将float乘上不同的系数。如dip/dp需乘上屏幕系数，sp需乘上字号的缩放系数，pt、in、mm等也是根据相应的算法进行换算。\n\n\treturn value * metrics.density; 这个代码跟我们平时手动写dp2px方法的代码几乎是一样的，我们平时可能是为了误差的问题在后面加上0.5*density。\n\n其实这里有有一点要提的是：dp px  mm 等，在系统中都是以 \"数值+单位\" 在系统中存储的。\n\n比如：\n``` xml\n\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e  \n\u003cresources\u003e  \n    \u003cdimen name=\"zl_def_indicator_radius\"\u003e4dp\u003c/dimen\u003e  \n    \u003cdimen name=\"zl_def_font_size\"\u003e16sp\u003c/dimen\u003e  \n\u003c/resources\u003e  \n\n```\n这种存起来的时候都是以 \"数值+单位\" 存储的.\n\nAndroid的Resoureces类的getDimension方法，对于不同的dimension，在使用getValue获取到对应的int值之后，会通过TypedValue的complextoDimension方法将其转换为float。\n\n# \n\n本文涉及到的github的android源码，地址如下：\n\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/Context.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/Resources.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/AssetManager.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/util/TypedValue.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/TypedArray.java\n\thttps://github.com/android/platform_frameworks_base/blob/master/core/java/android/content/res/Resources.java","lang":"cn"},"__N_SSG":true},"page":"/[lang]/blog/[slug]","query":{"lang":"cn","slug":"%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B8%ADgetDimension%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"},"buildId":"HT0wMZc9WfQm5UQ_5R-LL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>