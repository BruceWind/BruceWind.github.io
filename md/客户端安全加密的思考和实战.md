title: 客户端安全加密的思考和实战
date: 2017/02/18 21:53:33
updated: 2017/02/19 16:58:41
categories:
- 技术
---
本文是面向native安全设计。
> 大家所知道的android程序员再代码安全方面做的大多数仅仅是把代码放到到so里面就可以了，那么实际上这样子安全吗？
实际上，我作为一个爱思考的android程序员，我连会hack玩的一些高端的东西都不会，也轻松破解你。

# 
在参与一个项目时，发现安全加密需要客户端做，但是作为一个有代码精神的程序员，我有几个问题需要慎重参与跟同事考虑几个重要的问题：
1.使用什么加密算法？
2.算法怎么保密？
3.key怎么做保密？
4.hack常见的破解我本地代码的手段是什么？


常见的大家都是去做对称加密， 来保证网络传输的数据安全性，算法大家一般都是AES，可能老的一些项目还在使用3DES算法，AES主要就是性能高所以目前大量放弃AES。
# 
回到破解的方向考虑，我怎么防止被人破解：
### 几种方案：
 1.key存到so中:
> 作为一个开发者来说，你觉得key是加密的核心，你把key存到native中，然而，我反编译一下apk，从java代码里看到你的全部代码是AES算法，我觉得破解你的核心是key，我只要拿到你的key，看到你把key存到c中了，通过调用一个jni接口，就可以拿到你的key，这个时候我的破解方案就是，修改你的java代码，在代码里插入一行代码把jni取到的key打印到日志里，再二次打包运行即可。
# 
2.key和算法都存在so中：
> 如果上面的破解者只是一个普通的android程序员，可能这个时候还是可以破解你的，他不再目的为了取到你的key，而是仅仅当作你的so只是一个加密算法而已，我不用去破解你的so，只需要知道怎么调用你即可，我编译一下你的apk，看下你的java代码，就看到你怎么调用了，我就可以在新项目里就可以调用。
这样子的话，我有个高级的方案，就是防止二次打包，问题在于，这个时候我怎么防止你二次打包，这个解决方案就是keystore的md5或者hashcode，就是在java调用so中的加密算法时，c的代码里要先去检查一下当前应用的包名应用的keystore的hashcode。这个校验一定要在c里面做，java太容易篡改，于是会有下面一个安全方案：
# 
3.key 和 算法同时在so中，并做防止二次打包的校验：
> 这个时候，做为一个android程序员我已经很难破解了，我看不到你的key，最多，我只能在反编译apk dex文件时看到你的jni接口的命名，大概看出你是aes算法加密，只是我拿不到你的key。但是，目前我已经几乎看到两个点。这个时候，作为一个android程序可能很难破解你了。
普通android程序员大概只是知道你是一个aes算法，但是，我如果能拿到你的key，还是可以破解。
这个时候，我用IDA去反汇编so，发现竟然直接看到了你的key，这个时候怎么防止我去反汇编呢？
ndk有个配置是符号表，可以用符号表存一些字符串，把这些东西存到符号表中，然后再ndk编译时使用隐藏符号表的方案。
ok，是的这是个好方案。
在尝试之后发现反汇编之后确实无法看到key的字符串了。IDA和objdump两个软件都有尝试结果同样看不到字符串了。
第一张，图我代码里使用了 `uint8_t AES_KEY[] = "1234567890abcdef";`
![](assets/key.png)
第二张图我反汇编之后，还可以看到这个字符串。
![](assets/section.png)


# 
4.key 和 算法同时在so中，并做防止二次打包的校验,在隐藏符号表
> 这个时候，IDA是不行了，然后作为一个linux用户，我想想别的方案，发现apt仓库里有个objdump，我用objdump反编译一下，直接就看到你key。
那么现在怎么办呢？有个方案，就是我的代码里存的key并不是一个真实的key，我把key做一些变换之后才能用，变换的代码我写在c里面，调用so里面的加密算法之前，我需要先调用c的init方法，生成好真实的key。
# 
5.非真实的key存在so中，再生成真实的key，同时给so，做防止二次打包的校验
> 那么，我想办法还是可以破解你，我利用堆栈溢出从内存地址中取到你生成好的key。
这时候，从这个攻防的等级逐渐加深，你会发现，原来key是非常不安全，总能想办法破解你，拿到你的key。
# 
## 加密的核心无非就是两点：
> - 1.加密算法
> - 2.key
算法方面除非你用自定义加密算法，否则很难保证不被人猜到，就那么常见的几种加密方式，AES，DES杂七杂八。
那么，key的安全性设计就是更加的难了，只要你的key写在代码里，或者通过运行时生成的方式生成再内存中，我总是可以详尽办法拿到你的key。
这样子的话，算法和key都很好搞定。

# 所以
最好的安全设计方案是自定义加密啊算法，在AES上面大量的修改，或者在Base64上做大量修改，c的代码被打包成机器码之后不但很难看懂，而且几乎没法二次打包，另外就是本地客户端不存key，也不通过服务端下去发key。
几个常见的例子：
##《模仿游戏》
模仿游戏中德国采用的“英格码”无法破译，他的涉及思想就是网络传输中不发送key，同时没有一个固定的key，防止你去破解，就是动态key技术，导致你就算抓到他的秘文用超级计算机取暴力破解，破解出来也已经是当时的key了，你再去破解今天的数据的时候，key已经变了。
这个是到动态key的涉及思想。

## SSH的设计思想
本机电脑上存储一个key，server端存储一个key，使用者一般通过key访问server，key涉及的特别的复杂，就算超级计算机破解也需要很长时间，如果用户发现自己的key被破解了，那么直接后台删除掉这个key重新生成一个key。这也是一种动态key设计思想，只不过他的变化规律无迹可循，而且用户可以再自己帐号被盗之后重置加密key。

# 
这都是针对你的平台田地多，防止专业的破解团体来说的，而针对小的破解团体的话，你只要保证算法不被猜到，同时客户端不存key，而且不在网络传输的传递key即可提升破解难度。

    想起曾经参加安卓巴士搞得一个安全方面的座谈会，我靠，360和阿里聚安全的大佬在台上信誓旦旦的说只要你把所有的代码放到native去实现，安全就已经提升了很高的等级，但是后来自己尝试破解native才知道，他妈的都是狗屁，破解native也特么的很简单。

#  反汇编可以看到很多东西
1.方法名：就可以看到你的加密算法了，这个时候你可以用JniOnload去做映射，防止被看到方法名。
2.代码里写的string，所以key完全不能存到代码里。

## 所以，为了防止被反汇编，有一些方案去帮助你

利用使用O-LLVM在NDK打包so时进行混淆处理，增加那些专门做逆向编程的人的破解难度。
如果本地非要存字符串，请不要存真实的，而是需要经过转换的字符，先存一个非真实字符到字符表，再配置隐藏字符表，然后运行时不能把key生成到一个static字段中，这样子很容易利用堆栈溢出pop出你的值，所以就算做本地转换也请用短生命域的临时变量去做，用完即可丢弃，c的释放内存速度超级快，只要引用计数降低到0即可释放，也就是说这段加密算法走完，key就丢弃了。
例子代码：
```
static char* base_key="HJDKHFDSJFDFHA324723894djksfh";

char* encode(Stirng str)
{
    return encode(str,getRealKey(base_key));
}

char* encode(char* str,char* key)
{
    char * strEncode;
    //todo something
    return strEncode;
}

char * getRealKey(char* base)
{
    char* realk="";

    //TODO something
    return realk;
}
```
这样子，你代码里并没有存真实的key，然后NDK打包又经过混淆，做逆向的人就很难从汇编中看出你的生成key 的算法了，想要利用堆栈溢出pop出你存在静态变量里的key也拿不到真实的key，而动态字段存在内存空间中的时间1毫秒都不到根本不能pop出。


## 鸣谢

> https://www.linux.com/blog/4-ways-password-could-be-hacked-using-common-linux-tools