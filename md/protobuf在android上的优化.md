title: protobuf在android上的优化
date: 2017/03/29 10:34:58
updated: 2017/03/30 12:40:52
categories:
- 技术
---
protobuf相信很多接触过socket的项目都用到过，消息推送，即时通讯，很多直播平台弹幕也是在使用protobuf。
json的诞生主要解决了xml时代的数据包过大的问题，json的解析性能也比XML稍微好那么一点。

但是，新时代的互联网流量，数据流量早已翻了一个数量级，json解析的性能和流量的耗费已经几乎无法满足人类的贪婪，所以为了全面实现小康社会，实现社会主义的伟大理想，protobuf诞生了，主要优化了json的包体过大和性能问题。

比如，一个两个字段的消息包：
```
{
    key1:"ha",
    key2:"ha"
}
```
包含两个字段的对象而已，在json上耗费需要21个字节。
换成PB之后，因为使用Varints序列化算法，第一个字符串长度为2，但是需要一个字节表示字段类型，一个字段类型表示字段标号，所以需要+2，后面一个字符串同理，两个字符串在一起就是8个字节。流量大大压缩，这也是很多公司选择PB的一个原因。
# 
另外就是json的parse的过程耗时太久，android平台的DVM虚拟机不是基于栈而是基于寄存器，已经是很快的java虚拟机了，但是还是在遇到较大的json结构的时候，还是耗时在70-80ms左右的情况，Java方面的Json转化的过程是反射，虽然有fastjson这个库是一个不用反射做，而是操作字节码，但是fastjson在android平台也没有操作字节码，因为android的字节码比较特殊，dvm又不遵守JVM规范，不能完全拿JVM那一套来理解DVM的行为，所以android平台的json parse几乎都是反射作为parse的核心。
PB的序列化和反序列化因为算法较为简单，性能稍微好一些。
# 
好了，废话说完了，那么本文的重点来了，json不好的点那么多，PB是不是缺点也很多呢？
android平台使用PB真恶心，proto协议文件转java，转出来非常大，proto文件里随便定义点东西，转出来就是1M+的代码量，2w行+的代码。

当然，proto文件中可以配置优化选项，选择优化codesize：
```
option optimize_for = CODE_SIZE;
```
然后生成的java文件最小的配置，总大小是800KB多点,其实还是难以接受的。
但是,这样子性能不好，而且其实codesize也没有优化到我们觉得合适的大小。
proto还有个配置是：
```
option optimize_for = SPEED;
```
这个代码执行性能最好，生成的代码量最大。

> 还有个 LITE_RUNTIME:这个是上面两种兼得的方案，性能最好，生成的包也小，但是没有达到CODE_SIZE配置的小。

android平台multidex的坑很多人都会遇到，方法数要超过65535，就会掉坑里，那么问题来了，PB这生成快1M的java代码不就是轻轻松松掉坑里嘛，对的！！！


所以，性能 和 文件大小二者不可得兼的情况下，导致android平台使用PB非常的坑爹。。。

开发者深感疲惫，java代码过多会带来很多问题，编译慢，app启动时，类的加载器进行类的加载的耗时也长，项目为了使用PB，开了Multidex之后，又需要填multidex的坑，总之各种烦。
## 烦烦烦！！！

## 其他缺点
代码太多的问题是个重头缺点，其他缺点，还有一些，proto文件转JAVA类使用的工具，也是麻烦，特么的真恶心，那个烂工具需要在电脑做一堆的配置才行，mac和windows用户都很麻烦，我的电脑是linux还好，因为开放的特性，apt仓库里已经加入了protobuf-compiler这个软件,这个时候linux的优点就提现出来了，直接命令行里输入protobuf，系统提示我没有这个命令，推荐我安装这个protobuf-compiler,我一个命令行，一分钟不到就安装好，之后就可以直接命令行转java了，linux开发还是方便很多，mac，windows就麻烦许多。
生成这么大的class文件我导入到AS中，AS会卡死很久，这个坑可是非常的大。因为代码太多，AS需要做一堆的检查，还有git比对，我靠，要死他妈的，卡几分钟有没有！！！！

所以，这个时候是不是有合适的优化方案去解决，size和 性能二者不可得兼的问题。

>  你的代码只有不断优化，不断重构才能达到极致，公司必须给程序员更多的空余时间，程序员才有时间思考优化的方案，我喜欢这样的公司。

## 优化方案
很不幸的是不知道国内用PB的都不去想办法优化还是怎么着，这方面的资料基本为0!!! 国外也是很少！！！

### Wire
> 其实，我翻阅了国外的很多杂七杂八的优化方案，发现这个还是最靠谱的。

wire是square公司推出的一款优化proto在android平台的整套解决方案，包括生成java类，运行时优化，生成较小的java类同时又保证性能，这是一个不错的库。

解决的问题：
1.CODE文件过大；
2.性能不能最优；
3.生成新的class电脑需要配置；
4.AS因为Code过大会卡住；


### 生成：
proto 文件和compiler的jar包放在同一目录下，使用命令行
```
java -jar ./wire-compiler-2.2.0-jar-with-dependencies.jar --proto_path=./ --java_out=gen/java/
```
因为是用java生成code，团队中每个开发电脑都肯定有JAVA环境的，所以是没有电脑需要配置的问题。生成出来会从1.2M降到280K,非常小，优化了快1M的大小,简直完美！！！

### 使用：
需要在gradle中集成runingtime依赖包，wire还会帮忙生成proto依赖的google的class，可以选择删除项目中原来以来的旧的proto的jar，导入生成好的几个class，可以帮忙节省一些打包出来的apk大小，如果项目从proto官方Message方案转到目前的wire方案，改动很小，wire为了保证迁移的成本，故意设计的更像官方的Message方案，我基本上1小时不到就迁移完毕了。

### wire缺点：
这个库是在假设服务端返回字段都是健全的，不能缺少字段，它不会生成基础类型，都是装箱类型，说装箱很难理解，说简单点就是不用int，用Integer，因为不是基础类型，字段没赋值就会NULL异常，导致app崩溃，蛋疼的就在这里，这是一个非常蛋疼的点。

另外一个缺点就是proto文件中定义的enum的一些ID没有生成static final int的字段给我们使用，需要手动写常量，这个还是比较好处理的。

上面哪个null的问题，可比较难处理，这里需要去怼服务端，给老子正常的数据，虽然怼了，服务端承诺了不会再有这种情况，但是，老子信不过他。

人和人之间最基本的信任呢？？？？？what the fuck！

理解并重新编译wire-compiler库的源码？重新生成基础类？这个方案行不通，因为还要重新打包wire-runnigtime的代码，整个过程耗时可能不是一两天天的事情。我的选择我自己做了一个简单的类似JSON转化的组件，这个组件实现的功能是丢进来一个对象，我用反射去遍历所有的字段，然后对每个字段判空，给它设置一个默认值，int这种基础类型，你定义了一个字段，不设置值他的默认值是0，wire生成的Integer理应得到一个0的默认值，而不是NULL，所以解决方案就是这样子。
这个解决了就没有问题了，那么剩下的就是这个方案的实现。实现起来也是很麻烦的，涉及到一些Java特性的无法alloc的问题，处理起来也是比较棘手的，我是拿了Gson的源码中的两个类过来，因为之前项目里我做过这种东西，以前做过类似的JSON容错类，所以我把代码挪过来简单改下就直接用了。





