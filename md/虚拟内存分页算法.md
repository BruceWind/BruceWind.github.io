title: 虚拟内存分页算法
date: 2015/11/03 09:39:06
updated: 2016/01/28 17:09:19
categories:
- 技术
---

> 首先自己得认错，自己作为一个学软件的，大学学《操作系统》这门课程的时候，没有认真的学(!＝_＝)，但是也算是学到了一点点东西，比如虚拟内存分页算法，起码懂得一点点其中的原理性的东西了。

如下这段话，取自 ***《Linux 内核设计与实现》*** ：

# 

内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字（甚至字节），但是，内存管理单元（ MMU ，管理内存并把虚拟地址转换为物理地址的硬件）通常以贞为单位进行处理。正因为如此， MMU 以页（ page）大小为单位来管理系统中的页表（这也是页表名的来由）。从虚拟内存的角度来看，页就是最小单位。在第 19 章中我们将会看到，体系结构不同，支持的页大小也不尽相同，还有些体系结构甚至支持几种不同的页大小。***大多数 32 位体系结构支持 4KB 的页，而 64 位体系结构一般会支持 8KB 的页。*** 这就意味着，在支持 4KB 页大小并有 1GB 物理内存的机器上，物理内存会被划分为 262144 个页。

----------

### 看到这里，忽然想到U盘需要进行4K对齐了。
于是乎我找了一篇帖子，看看U盘 SSD之类的进行4k对齐和内存分页的4K的区别。
[点击跳转到](http://www.4k123.com/thread-9365-1-1.html)

文中说到了4K对齐的原理：
	
	HDD机械硬盘以扇区（512字节）为单位，可直接覆盖写入新数据。而SSD固态用盘则以页（典型为4KB）为单位进行读写操作，但擦除时却是以块（典型为128个页）为单位。由于SSD无法直接覆写，所以有数据的页必须先擦除才能写入新数据，经历“读取→擦除→写入”的过程。传统硬盘分区会从起始偏移为63个扇区（这63个扇区用于保存主引导记录、分区表等信息），也就是分区偏移了31.5K，数据起始4KB在31.5KB～35.5KB，位于第8和第9页，以此类推其后所有数据都占用2个页。换句话说，如果4K没有对齐，覆写时需要对2页进行“读取→擦除→写入”操作，从而降低了SSD的效率。而4K对气候，覆写时就只需进行1页操作。

这里说了原理，但是实际测试中，拷贝文件的速度***提升了32%***！！！！！！


好吧，似乎和内存分页没什么关系。

---------

### 我们继续谈虚拟内存分页，先谈谈虚拟内存分页的原理：

 先用我自己的语言，简单的描述下虚拟内存的目的和原理。

虚拟内存的目的就是，在这个内存还是很有限的时代，人们买不起太大的内存，应用软件和系统软件对内存的消耗过大，需要将硬盘的存储空间作为内存的一部分，来存储那些不是活动的资源，比如Bitmap，Dll(动态链接库)，不活动的进程包括不常用的系统进程，还有其他的一些资源。 可能以后就不再需要内虚拟内存技术了，因为内存变得很大了。

安装 linux 的发行版的时候，会要求设置虚拟内存的分区，一般虚拟内存的分区大小**为实际内存的2倍**，再安装之前 需要将分区格式化为 SWAP 格式。我机器是Ubuntu，设置了Swap分区大小接近 **8G** 。
	
![](assets/56a9daa5ab64417776003617.PNG)

![](assets/56a9daa5ab64417776003615.PNG)

### 虚拟存储器的概念，我找了个描述的原理讲的比较清晰易懂的：

	虚拟存储器的思想是程序、数据和堆栈的大小都有可能超过物理内存大小，由操作系统把当前使用的放在内存，而不需要的放在磁盘。
    而绝大部分操作系统使用的虚拟存储器技术就是分页技术。
    在虚拟存储器中，程序所产生的地址为虚拟地址，虚拟地址构成了虚拟地址空间。（当然了在没有虚拟存储器的系统上，程序产生的地址就是物理地址。其实程序并不知道，只是操作系统和处理器知道。下面都是按照使用虚拟存储器的系统来说）这些虚拟地址通过MMU（内存管理单元）映射为物理地址。
    采用分页机制的系统，虚拟地址空间以页面为单位进行划分，虚拟地址空间会被划分成多个等大小的页面。物理地址空间也按页面为单位进行划分每一块成为页帧，或者页框。每一虚拟页面可以随意对应到物理页框，也可以对应到磁盘的页面文件的上。
    我们按照IA32的分页机制来说，标准页面大小为4K。
    例如一条mov指令：mov eax,[0];
    此时虚拟地址0将被发给MMU，MMU发现0属于页面0的范围内，如果页面0对应的页框号为1，那么物理地址在物理地址4096-8191范围，此时就会将4096发送到地址总线上。因为虚拟地址0的页内偏移也是0（页内偏移：在页面里的位置，比如1，的页面偏移是1，4097的页面偏移也是1，这是因为一个页面大小为4K，用虚拟地址 mod 4k就得到了页内偏移）。
    就类似mov eax,[4095];mov eax,[4096],4095属于页面0，页面0对应页框1，那么物理地址为8191，而4096属于页面1的范围，如果页面1对应页框0，此时的物理地址就是0。
    由上面可以看出，虚拟地址空间是连续的，而物理空间是可以不连续的。也就是说一个程序只要保证他的虚拟地址空间是连续的，它就可以正常运行。
    上面说的是虚拟地址到物理地址的映射的简单情况。可是如何记录这些页面到页框的映射关系呢？(当然也有些处理器系统是页框到页面的转化)。在IA处理器上使用的是页表，就是在物理内存里有一块连续的空间，来记录这些页面到页框的映射关系。每一个页表项里都有一部分去指向页框的起始地址，还有部分记录了这个页面的属性。可以通过页面号来做索引。页面号就是虚拟地址 / 4K，得到的整数部分。
    当然如果只是单一的页表，也是有问题的，如果虚拟地址空间过大，那么页表所占的空间也会很大，这时候可以采用多级页表。IA32在采用4K页面的时候就使用了2级页表，IA64使用了4级。
    其实两级也很简单，最上一级就是一个总的目录指示每一个二级页表的起始物理地址，可以在页号的高几位来索引页目录项。例如IA32就是通过虚拟地址的高10位来索引页目录项，然后中间10位来索引页表项。
    这样，我们就可以只将用到的虚拟地址空间的页表写入内存，而没有用到的虚拟地址空间的页表就不写入。
    例如，我们正好是只用了虚拟地址0-0x3FFFFF，那么我们可以在页目录第0项指向一个页表，这个页表就只表示了虚拟地址地址0-0x3FFFFF到物理地址空间的映射关系(因为高10位为页目录索引，页目录第0项，就表示了虚拟地址高10位必为0，也就是说只有低24位有效，所以最大只能到0x3FFFFF)。


以上这段话取自：[CSDN问答模块](http://bbs.csdn.net/topics/110077016/)
	
算是我找到的最清晰易懂的，对原理解释的最深的了。

--------
### 说一下几种内存分页算法：

>- 1.OPT  最佳替换算法。
>替换下次访问距当前时间最长的页。opt算法需要知道操作系统将来的事件，显然不可能实现，只作为一种衡量其他算法的标准。

>- 2.LRU 最近最少使用。 
>替换上次使用距离当前最远的页。根据局部性原理：替换最近最不可能 访问到的页。性能最接近OPT，但难以实现。可以维护一个关于访问页的栈或者给每个页添加最后访问的时间标签，但开销都很大。

>- 3.FIFO 先进先出。
>将页面看做一个循环缓冲区，按循环方式替换。 这是实现最为简单的算法，隐含的逻辑是替换驻留在内存时间最长的页。但由于一部分程序或数据在整个程序的生命周期中使用频率很高，所以会导致反复的换入换出。

>- 4.CLOCK  时钟替换算法。
>给每个页帧关联一个使用位。 当该页第一次装入内存或者被重新访问到时，将使用位置为1。 每次需要替换时，查找使用位被置为0的第一个帧进行替换。在扫描过程中，如果碰到使用位为1的帧，将使用位置为0，在继续扫描。如果所谓帧的使用位都为0，则替换第一个帧。



LRU算法值得提一提，LRU在android上Bitmap内存管理上使用了。android官方对java虚拟机做了修改，当然谷歌团队也因此也违反了ORACLE公司的一些意愿，所以今年谷歌被
ORACLE告上了法庭。其中的修改，很多很多，我们不提了，今天就只提及内存这块的修改。
由于android虚拟机，对每个app最大可申请内存限制，GC释放的修改等等。
最大内存限制，不同的版本的android限制不同，我们只说官方ROM，2.2的机器是8M，之后也有32M，4.0之后是64M，然后到了5.0就变成了96M，为什么慢慢变大了呢？其实不是java对象变大了，内存消耗变大了，而是屏幕变大了之后，Bitmap想要显示的清晰，就要保证尺寸也很大，由于Bitmap在任何一个系统上单个像素对内存消耗都是4Byte，所以慢慢就变大了，当然64位架构CPU的引用也是一方面。

以前人们在开发图片载入框架的时候使用的是java的**软引用**，软引用带来的问题就是：**你不知道他什么时间被释放了，当你使用资源的时候，这个资源在不在内存中就会导致你很困惑。** 
所以，android平台，一些比较新的图片载入框架，**都是采用LRU算法来管理Bitmap**内存，放弃使用java软引用。自己重建Hasmap，使用强引用，什么时候被释放，自己都清楚，如果使用时判断已经被释放，就从本地磁盘中重新读取到内存中使用。