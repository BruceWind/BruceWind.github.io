title: TCP保活机制的探究
date: 2017/03/15 16:06:05
updated: 2017/07/13 00:59:09
categories:
- 技术
---
# 为什么需要做TCP保活?
每个连接都会在路由器交换机上建立一个session,session就是路由器上的会话,但是路由器交换机的负载有限,他会自动释放一些它认为无效的session,来降低机器负载.
> 在不考虑路由器CPU的情况下,session负载数是基于RAM的大小来计算的每个session都会消耗一些内存
# 
一般长时间你的session没有数据传输,路由器交换机,就会主动给你释放掉.

这里需要补充的是运营商,运营商也提供交换机路由器,他们的释放时间是:
> 1.电信10分钟
> 2.联通5分钟
> 3.移动5分钟

然而我查了下国外的运营商.....不说了....此处省略一万字.
# 
如果session被释放了,这个时候你的TCP已经断掉,但是不会收到任何断开的通知,如果正常手动断开,需要发送断开信号,也就是FIN信号,而且网络也没有断开,应用层无法收到任何回调,就会出现看上去TCP连接着,但是TCP已经无法收到消息的情况,你的任何isConnected() 都是正常的.

**保活的解决方案无非就是定时发送数据,这就是解决方案.**

# 项目中实际处理过程介绍:
## 一.系统提供TCP保活定时器:KeepAlive定时器
Socket在包装给上层Java应用使用TCP的时候会提供setKeepAlive方法,NIO框架可以设置多少时间内没有数据收发就发送探测包.

### Java中最最基础的Socket类.
java.net.Socket这个类,有个setKeepAlive(boolean) 的方法,然后踩过坑才知道他并没有什么卵用,网上40%的博客还在说设置了keepAlive之后有效,实际上咳咳咳,然后一部分说无效的也并没有说为什么无效,我也是在一些项目上踩坑,然后才知道为什么,java.net.Socket这个类有个setKeepAlive,他并没有提供设置多久没有数据就发送探测数据包的设置,刚刚我说了踩过坑,就是我并不知道他是多久才会发,我也是最近才查到他是多久才会发探测数据包.
原来,他会调用系统设置的默认值,我用adb命令进去抓取了android系统的默认值.
```
# cat /proc/sys/net/ipv4/tcp_keepalive_time
7200
# cat /proc/sys/net/ipv4/tcp_keepalive_intvl
75
# cat /proc/sys/net/ipv4/tcp_keepalive_probes
9
```
这个值,看上去跟普通的linux值一样的,问题是他妈的 是7200秒,两个小时啊!!!!!别说运营商了,很多品牌的防火墙都主动给你释放掉估计.

     后面两个命令是探测包发送失败时侯，重试次数和失败重试的时间间隔。

java提供这个接口,然后把这个任务交给系统,使用系统的这个值,如果你做服务端开发可以去手动修改这个值,但是android,我特么也是吡了狗,根本无法修改好不,这个需要root.
所以,这个如果不主动去设置,在android上使用java默认的这个值的话,不但没有起到作用而且对系统资源产生浪费,但是特么的java本身不提供设置这个东西,我擦,太恶心了,这就是为什么需要一个nio框架的原因,nio框架提供设置这个值的方法.

# 二.应用层手动发数据方案

如果你没有选择使用NIO框架,那么问题就来了,客户端怎么自己设计定时发送数据呢?

***1.应用层发送自定义心跳包***
这个方案很常用,但是真的很土，需要定义客户端跟服务端定义的json或者protocbuf协议里插入数据，浪费流量不说，还会浪费应用程序CPU性能,如果使用keepalive就由系统去做这个事情,系统提供的keepalive定时器,发出去之后,仅仅通过系统网络缓冲区处理掉,不会真正移交数据给应用层的,这个才是一个优雅的方案.
但是，大家一贯采用这个做法的原因，并不是客户端需要用这么土的方案来检测TCP是否失效，而是服务端要求加这个，目前我遇到的几个涉及到Socket的项目，服务端都主动设计出这个心跳包协议，服务端不能保证客户端是否有BUG，出现bug了自然不能很好的工作，但是连接没有断开，这就带来服务器资源浪费，服务器开发一般会定义这种心跳包的协议让客户端应用层层做定时，定时发送给他们。

***2.使用Urgent ***
自己做一个定时器,定时调用socket.sendUrgent(),是一种解决方案,这一个字节的URG包,只会被网卡和系统底层处理,不会丢给应用层,理论上来说感觉是比较靠谱,保证了浪费的流量最小,还保证了没有浪费应用的CPU性能.
他如果发送失败，会直接把异常往java应用层抛出来，你就可以捕获到这个异常。

但是这个东西,并不推荐使用,只是可以作为一个稍微优雅一点的方案来替你们应用层协议中定义心跳协议的方案，如果你们本来就有应用层协议心跳，比如微信这种，而且心跳的时间是２－３分钟，那么就没有必要做保活,你不需要用urgent,也不需要keepalive,启用keepalive系统还要开一个定时器给你这个TCP用，只要你们跟服务端定义的心跳协议能稳定使用，完全不需要这些玩意.
# 
你用抓包软件可以看到,网卡发出一个URG数据包,可能你抓到的最多的都是ACK，RST之类的包,URG一般情况下很少用,也不推荐使用.

[TCP/UP GUIDE网站](http://www.tcpipguide.com/free/t_TCPPriorityDataTransferUrgentFunction.htm)上有对urgent的说明.

> URG信号概念：为了处理数据流的某一部分需要以比其余部分更高的优先级发送的情况，TCP并入了“紧急”功能。当需要发送关键数据时，应用程序将此信号通知给其TCP层，TCP层使用TCP片段中设置的URG位发送它，绕过可能已经排队等待传输的任何较低优先级数据。

URG信号发送过于纷繁,有可能某家防火墙以为这是个攻击,会直接给你的session干掉,好吧,说多了都是泪,踩过思科防火墙的坑才知道心痛.
所以最好还是老老实实选择NIO框架,除非你们服务端已经约定了你的心跳协议包时间比较短.

### 微信关于心跳保活的设计：

    摘录自：即时通讯网

> 微信自从登录成功后,创建的业务链接每隔2分钟即会向服务器发送一个82字节的心跳包。由于Android系统允许程序在后台运行,当微信被 切入后台后,微信的业务链接并没有断开,将继续以此频次发送心跳包。也就是说,Android版本的微信只要运行并登录成功后,将24小时不间断地发送心跳包,这样, 即使对微信不进行任何操作,微信 每天将发送24x30=720个数据包, 数据量为24x30x82=59K字节,按月计算折合每月22 320个数据包或 1.83M字节数据。


----------------------------------

延伸阅读：
[微信的大规模使用真的会过多占用信令，影响通讯稳定吗？](https://www.zhihu.com/question/20849677)
[为什么QQ用的是UDP协议而不是TCP协议？](http://www.52im.net/thread-279-1-1.html)
